#!/usr/bin/env python3
import os
import re
import aiohttp
import asyncio
import threading
from pathlib import Path
from datetime import datetime, timedelta
from pyrogram import Client, filters
from pyrogram.types import Message, BotCommand, InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery, InputMediaPhoto, InputMediaVideo
from pyrogram.enums import ParseMode
from PIL import Image
from hachoir.parser import createParser
from hachoir.metadata import extractMetadata
import subprocess
import traceback
import json 
from flask import Flask, render_template_string
import requests
import time
import math
import logging
import yt_dlp

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# env
API_ID = int(os.getenv("API_ID"))
API_HASH = os.getenv("API_HASH")
BOT_TOKEN = os.getenv("BOT_TOKEN")
PORT = int(os.getenv("PORT", "10000")) 
RENDER_EXTERNAL_HOSTNAME = os.getenv("RENDER_EXTERNAL_HOSTNAME") 
ADMIN_ID = int(os.getenv("ADMIN_ID", "0"))

TMP = Path("tmp")
TMP.mkdir(parents=True, exist_ok=True)

# --- EXISTING STATE ---
USER_THUMBS = {}
TASKS = {}
SET_THUMB_REQUEST = set()
SUBSCRIBERS = set()
SET_CAPTION_REQUEST = set()
USER_CAPTIONS = {}
USER_COUNTERS = {}
EDIT_CAPTION_MODE = set()
USER_THUMB_TIME = {}
MKV_AUDIO_CHANGE_MODE = set()
PENDING_AUDIO_ORDERS = {} 
CREATE_POST_MODE = set()
POST_CREATION_STATE = {} 
BATCH_CAPTION_MODE = set()
BATCH_DATA = {}
BATCH_STATUS_MSG = {}
USER_QUEUES = {}
USER_WORKERS = {}
USER_UPLOAD_LOCKS = {}
YT_DATA = {}

# --- NEW STATE FOR CHANNEL POST BOT ---
CHANNELS_FILE = 'channels.json'
user_data = {} # Stores session state for posting

# States for Post Bot
STATE_IDLE = "IDLE"
STATE_AWAIT_MEDIA = "AWAIT_MEDIA"
STATE_AWAIT_CAPTION = "AWAIT_CAPTION"
STATE_AWAIT_BUTTONS = "AWAIT_BUTTONS"
STATE_AWAIT_FORWARD_SAVE = "AWAIT_FORWARD_SAVE"
STATE_AWAIT_FORWARD_EDIT = "AWAIT_FORWARD_EDIT"
STATE_EDIT_MENU = "EDIT_MENU"
STATE_EDIT_NEW_MEDIA = "EDIT_NEW_MEDIA"
STATE_EDIT_NEW_CAPTION = "EDIT_NEW_CAPTION"
STATE_EDIT_NEW_BUTTONS = "EDIT_NEW_BUTTONS"
# New state for /id command
STATE_AWAIT_ID_FORWARD = "AWAIT_ID_FORWARD"

DEFAULT_POST_DATA = {
    'image_name': "Image Name",
    'genres': "",
    'season_list_raw': "1, 2" 
}

MAX_SIZE = 4 * 1024 * 1024 * 1024

# Updated workers to 1000 as requested
app = Client("mybot", api_id=API_ID, api_hash=API_HASH, bot_token=BOT_TOKEN, workers=1000)
flask_app = Flask(__name__)

# ---- utilities ----
def is_admin(uid: int) -> bool:
    return uid == ADMIN_ID

# Admin Filter for new handlers
def is_admin_filter(_, __, message: Message):
    return message.from_user and message.from_user.id == ADMIN_ID

admin_filter = filters.create(is_admin_filter)

# --- NEW UTILITIES FOR POST BOT ---
def load_channels():
    if not os.path.exists(CHANNELS_FILE):
        return {}
    try:
        with open(CHANNELS_FILE, 'r') as f:
            return json.load(f)
    except:
        return {}

def save_channels(channels):
    with open(CHANNELS_FILE, 'w') as f:
        json.dump(channels, f, indent=4)

# Load channels on startup
saved_channels = load_channels()

def get_edit_menu_markup():
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("Change Image/Video", callback_data="edit_change_media")],
        [InlineKeyboardButton("Change Caption", callback_data="edit_change_caption")],
        [InlineKeyboardButton("Change Buttons", callback_data="edit_change_buttons")],
        [InlineKeyboardButton("Update Post", callback_data="edit_update_final")],
        [InlineKeyboardButton("Cancel", callback_data="cancel_to_edit_menu")] 
    ])

def parse_buttons(text):
    if not text: return None
    rows = []
    for line in text.split('\n'):
        btn_row = []
        if ',' in line:
            for part in line.split(','):
                if '-' in part:
                    try:
                        name, link = part.split('-', 1)
                        btn_row.append(InlineKeyboardButton(name.strip(), url=link.strip()))
                    except: pass
        else:
            if '-' in line:
                try:
                    name, link = line.split('-', 1)
                    btn_row.append(InlineKeyboardButton(name.strip(), url=link.strip()))
                except: pass
        if btn_row: rows.append(btn_row)
    return InlineKeyboardMarkup(rows) if rows else None
# ----------------------------------

def is_drive_url(url: str) -> bool:
    return "drive.google.com" in url or "docs.google.com" in url

def extract_drive_id(url: str) -> str:
    patterns = [
        r"/d/([a-zA-Z0-9_-]+)",
        r"id=([a-zA-Z0-9_-]+)",
        r"open\?id=([a-zA-Z0-9_-]+)",
        r"https://drive.google.com/file/d/([a-zA-Z0-9_-]+)/"
    ]
    for p in patterns:
        m = re.search(p, url)
        if m:
            return m.group(1)
    return None

def generate_new_filename(original_name: str) -> str:
    BASE_NEW_NAME = "[@TA_HD_Anime] Telegram Channel"
    file_path = Path(original_name)
    file_ext = file_path.suffix.lower()
    
    file_ext = "." + file_ext.lstrip('.')
    
    if not file_ext or file_ext == '.':
        return BASE_NEW_NAME + ".mp4"
        
    return BASE_NEW_NAME + file_ext

def get_video_metadata(file_path: Path) -> dict:
    data = {'duration': 0, 'width': 0, 'height': 0}
    try:
        cmd = [
            "ffprobe",
            "-v", "quiet",
            "-print_format", "json",
            "-show_streams",
            "-show_format", 
            str(file_path)
        ]
        result = subprocess.run(cmd, capture_output=True, text=True, check=True, timeout=60)
        metadata = json.loads(result.stdout)
        
        video_stream = None
        for stream in metadata.get('streams', []):
            if stream.get('codec_type') == 'video':
                video_stream = stream
                break
        
        if video_stream:
            data['width'] = int(video_stream.get('width', 0))
            data['height'] = int(video_stream.get('height', 0))
        
        duration_str = metadata.get('format', {}).get('duration')
        
        if not duration_str and video_stream:
            duration_str = video_stream.get('duration')
            
        if duration_str:
            try:
                data['duration'] = int(float(duration_str))
            except (ValueError, TypeError):
                logger.warning(f"Could not parse duration string: {duration_str}")
                data['duration'] = 0 
        
        if data['width'] == 0 or data['height'] == 0:
            raise Exception("FFprobe returned 0 dimensions, trying Hachoir")

    except Exception as e:
        logger.warning(f"FFprobe metadata extraction failed: {e}. Trying Hachoir fallback...")
        try:
            parser = createParser(str(file_path))
            if not parser:
                return data 
            with parser:
                h_metadata = extractMetadata(parser)
            if not h_metadata:
                return data 
            
            if h_metadata.has("duration") and data['duration'] == 0:
                data['duration'] = int(h_metadata.get("duration").total_seconds())
            if h_metadata.has("width") and data['width'] == 0:
                data['width'] = int(h_metadata.get("width"))
            if h_metadata.has("height") and data['height'] == 0:
                data['height'] = int(h_metadata.get("height"))
            logger.info(f"Hachoir fallback successful for {file_path}")
        except Exception as he:
            logger.error(f"Hachoir fallback ALSO failed: {he}")
    
    return data

def parse_time(time_str: str) -> int:
    total_seconds = 0
    parts = time_str.lower().split()
    for part in parts:
        if part.endswith('s'):
            total_seconds += int(part[:-1])
        elif part.endswith('m'):
            total_seconds += int(part[:-1]) * 60
        elif part.endswith('h'):
            total_seconds += int(part[:-1]) * 3600
    return total_seconds

def progress_keyboard():
    return InlineKeyboardMarkup([[InlineKeyboardButton("Cancel ‚ùå", callback_data="cancel_task")]])

def delete_caption_keyboard():
    return InlineKeyboardMarkup([[InlineKeyboardButton("Delete Caption üóëÔ∏è", callback_data="delete_caption")]])

def mode_check_keyboard(uid: int) -> InlineKeyboardMarkup:
    audio_status = "‚úÖ ON" if uid in MKV_AUDIO_CHANGE_MODE else "‚ùå OFF"
    caption_status = "‚úÖ ON" if uid in EDIT_CAPTION_MODE else "‚ùå OFF"
    
    waiting_count = sum(1 for data in PENDING_AUDIO_ORDERS.values() if data['uid'] == uid)
    waiting_status = f" ({waiting_count}‡¶ü‡¶ø ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶¨‡¶æ‡¶ï‡¶ø)" if waiting_count > 0 else ""
    
    keyboard = [
        [InlineKeyboardButton(f"MKV Audio Change Mode {audio_status}{waiting_status}", callback_data="toggle_audio_mode")],
        [InlineKeyboardButton(f"Edit Caption Mode {caption_status}", callback_data="toggle_caption_mode")]
    ]
    return InlineKeyboardMarkup(keyboard)

def get_audio_tracks_ffprobe(file_path: Path) -> list:
    try:
        cmd = [
            "ffprobe",
            "-v", "quiet",
            "-print_format", "json",
            "-show_streams",
            str(file_path)
        ]
        result = subprocess.run(cmd, capture_output=True, text=True, check=True, timeout=60)
        metadata = json.loads(result.stdout)
        
        audio_tracks = []
        for stream in metadata.get('streams', []):
            if stream.get('codec_type') == 'audio':
                stream_index = stream.get('index') 
                title = stream.get('tags', {}).get('title', 'N/A')
                language = stream.get('tags', {}).get('language', 'und') 
                audio_tracks.append({
                    'stream_index': stream_index,
                    'title': title,
                    'language': language
                })
        return audio_tracks
    except Exception as e:
        logger.error(f"FFprobe error: {e}")
        return []

def has_opus_audio(file_path: Path) -> bool:
    try:
        cmd = [
            "ffprobe",
            "-v", "error",
            "-select_streams", "a",
            "-show_entries", "stream=codec_name",
            "-of", "default=noprint_wrappers=1:nokey=1",
            str(file_path)
        ]
        result = subprocess.run(cmd, capture_output=True, text=True, check=True, timeout=30)
        return "opus" in result.stdout.lower()
    except Exception as e:
        logger.error(f"Error checking OPUS audio: {e}")
        return False

def format_size(bytes_size):
    if not bytes_size or bytes_size == 0:
        return "N/A"
    size_name = ("B", "KB", "MB", "GB", "TB")
    i = int(math.floor(math.log(bytes_size, 1024)))
    p = math.pow(1024, i)
    s = round(bytes_size / p, 2)
    return "%s %s" % (s, size_name[i])

def generate_post_caption(data: dict) -> str:
    image_name = data.get('image_name', DEFAULT_POST_DATA['image_name'])
    genres = data.get('genres', DEFAULT_POST_DATA['genres'])
    season_list_raw = data.get('season_list_raw', DEFAULT_POST_DATA['season_list_raw'])

    season_entries = []
    
    parts = re.split(r'[,\s]+', season_list_raw.strip())
    parts = [p.strip() for p in parts if p.strip()]

    for part in parts:
        if '-' in part:
            try:
                start, end = map(int, part.split('-'))
                if start > end:
                    start, end = end, start
                for i in range(start, end + 1):
                    season_entries.append(f"**{image_name} Season {i:02d}**") 
            except ValueError:
                continue
        else:
            try:
                num = int(part)
                season_entries.append(f"**{image_name} Season {num:02d}**")
            except ValueError:
                continue

    unique_season_entries = list(dict.fromkeys(season_entries))
    if not unique_season_entries:
        unique_season_entries.append("**Coming Soon...**")
    elif unique_season_entries[-1] != "**Coming Soon...**" and unique_season_entries[0] != "**Coming Soon...**":
        unique_season_entries.append("**Coming Soon...**")
        
    season_text = "\n".join(unique_season_entries)

    base_caption = (
        f"**{image_name}**\n"
        f"**‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ**\n"
        f"**‚Ä£ Audio - Hindi Official**\n"
        f"**‚Ä£ Quality - 480p, 720p, 1080p**\n"
        f"**‚Ä£ Genres - {genres}**\n"
        f"**‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ**"
    )

    collapsible_text_parts = [
        f"> **{image_name} All Season List :-**", 
        "> " 
    ]
    
    for line in season_text.split('\n'):
        collapsible_text_parts.append(f"> {line}")
        collapsible_text_parts.append("> ") 
        
    if collapsible_text_parts and collapsible_text_parts[-1] == "> ":
        collapsible_text_parts.pop()
        
    collapsible_text = "\n".join(collapsible_text_parts)
    final_caption = f"{base_caption}\n\n{collapsible_text}"
    
    return final_caption


async def download_stream(resp, out_path: Path, message: Message = None, cancel_event: asyncio.Event = None):
    total = 0
    try:
        size = int(resp.headers.get("Content-Length", 0))
    except:
        size = 0
    chunk_size = 1024 * 1024
    try:
        with out_path.open("wb") as f:
            async for chunk in resp.content.iter_chunked(chunk_size):
                if cancel_event and cancel_event.is_set():
                    return False, "‡¶Ö‡¶™‡¶æ‡¶∞‡ßá‡¶∂‡¶® ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡¶ï‡¶æ‡¶∞‡ßÄ ‡¶¶‡ßç‡¶¨‡¶æ‡¶∞‡¶æ ‡¶¨‡¶æ‡¶§‡¶ø‡¶≤ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§"
                if not chunk:
                    break
                if total > MAX_SIZE:
                    return False, "‡¶´‡¶æ‡¶á‡¶≤‡ßá‡¶∞ ‡¶∏‡¶æ‡¶á‡¶ú 4GB ‡¶è‡¶∞ ‡¶¨‡ßá‡¶∂‡¶ø ‡¶π‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá ‡¶®‡¶æ‡•§"
                total += len(chunk)
                f.write(chunk)
    except Exception as e:
        return False, str(e)
    return True, None

async def download_url_generic(url: str, out_path: Path, message: Message = None, cancel_event: asyncio.Event = None):
    timeout = aiohttp.ClientTimeout(total=7200)
    headers = {"User-Agent": "Mozilla/5.0 (X11; Linux x86_64)"}
    connector = aiohttp.TCPConnector(limit=0, force_close=True)
    async with aiohttp.ClientSession(timeout=timeout, headers=headers, connector=connector) as sess:
        try:
            async with sess.get(url, allow_redirects=True) as resp:
                if resp.status != 200:
                    return False, f"HTTP {resp.status}"
                return await download_stream(resp, out_path, message, cancel_event=cancel_event)
        except Exception as e:
            return False, str(e)

async def download_drive_file(file_id: str, out_path: Path, message: Message = None, cancel_event: asyncio.Event = None):
    base = f"https://drive.google.com/uc?export=download&id={file_id}"
    timeout = aiohttp.ClientTimeout(total=7200)
    headers = {"User-Agent": "Mozilla/5.0 (X11; Linux x86_64)"}
    connector = aiohttp.TCPConnector(limit=0, force_close=True)
    async with aiohttp.ClientSession(timeout=timeout, headers=headers, connector=connector) as sess:
        try:
            async with sess.get(base, allow_redirects=True) as resp:
                if resp.status == 200 and "content-disposition" in (k.lower() for k in resp.headers.keys()):
                    return await download_stream(resp, out_path, message, cancel_event=cancel_event)
                text = await resp.text(errors="ignore")
                m = re.search(r"confirm=([0-9A-Za-z-_]+)", text)
                if m:
                    token = m.group(1)
                    download_url = f"https://drive.google.com/uc?export=download&confirm={token}&id={file_id}"
                    async with sess.get(download_url, allow_redirects=True) as resp2:
                        if resp2.status != 200:
                            return False, f"HTTP {resp2.status}"
                        return await download_stream(resp2, out_path, message, cancel_event=cancel_event)
                for k, v in resp.cookies.items():
                    if k.startswith("download_warning"):
                        token = v.value
                        download_url = f"https://drive.google.com/uc?export=download&confirm={token}&id={file_id}"
                        async with sess.get(download_url, allow_redirects=True) as resp2:
                            if resp2.status != 200:
                                return False, f"HTTP {resp2.status}"
                            return await download_stream(resp2, out_path, message, cancel_event=cancel_event)
                return False, "‡¶°‡¶æ‡¶â‡¶®‡¶≤‡ßã‡¶°‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø Google Drive ‡¶•‡ßá‡¶ï‡ßá ‡¶Ö‡¶®‡ßÅ‡¶Æ‡¶§‡¶ø ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶® ‡¶¨‡¶æ ‡¶≤‡¶ø‡¶Ç‡¶ï ‡¶™‡¶æ‡¶¨‡¶≤‡¶ø‡¶ï ‡¶®‡¶Ø‡¶º‡•§"
        except Exception as e:
            return False, str(e)

async def set_bot_commands():
    cmds = [
        BotCommand("start", "‡¶¨‡¶ü ‡¶ö‡¶æ‡¶≤‡ßÅ/‡¶π‡ßá‡¶≤‡ßç‡¶™"),
        BotCommand("upload_url", "URL ‡¶•‡ßá‡¶ï‡ßá ‡¶´‡¶æ‡¶á‡¶≤ ‡¶°‡¶æ‡¶â‡¶®‡¶≤‡ßã‡¶° ‡¶ì ‡¶Ü‡¶™‡¶≤‡ßã‡¶° (admin only)"),
        BotCommand("setthumb", "‡¶ï‡¶æ‡¶∏‡ßç‡¶ü‡¶Æ ‡¶•‡¶æ‡¶Æ‡ßç‡¶¨‡¶®‡ßá‡¶á‡¶≤ ‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶® (admin only)"),
        BotCommand("view_thumb", "‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶•‡¶æ‡¶Æ‡ßç‡¶¨‡¶®‡ßá‡¶á‡¶≤ ‡¶¶‡ßá‡¶ñ‡ßÅ‡¶® (admin only)"),
        BotCommand("del_thumb", "‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶•‡¶æ‡¶Æ‡ßç‡¶¨‡¶®‡ßá‡¶á‡¶≤ ‡¶Æ‡ßÅ‡¶õ‡ßá ‡¶´‡ßá‡¶≤‡ßÅ‡¶® (admin only)"),
        BotCommand("set_caption", "‡¶ï‡¶æ‡¶∏‡ßç‡¶ü‡¶Æ ‡¶ï‡ßç‡¶Ø‡¶æ‡¶™‡¶∂‡¶® ‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶® (admin only)"),
        BotCommand("view_caption", "‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶ï‡ßç‡¶Ø‡¶æ‡¶™‡¶∂‡¶® ‡¶¶‡ßá‡¶ñ‡ßÅ‡¶® (admin only)"),
        BotCommand("edit_caption_mode", "‡¶∂‡ßÅ‡¶ß‡ßÅ ‡¶ï‡ßç‡¶Ø‡¶æ‡¶™‡¶∂‡¶® ‡¶è‡¶°‡¶ø‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶® (admin only)"),
        BotCommand("rename", "reply ‡¶ï‡¶∞‡¶æ ‡¶≠‡¶ø‡¶°‡¶ø‡¶ì ‡¶∞‡¶ø‡¶®‡ßá‡¶Æ ‡¶ï‡¶∞‡ßÅ‡¶® (admin only)"),
        BotCommand("mkv_video_audio_change", "MKV ‡¶≠‡¶ø‡¶°‡¶ø‡¶ì‡¶∞ ‡¶Ö‡¶°‡¶ø‡¶ì ‡¶ü‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® (admin only)"),
        BotCommand("create_post", "‡¶®‡¶§‡ßÅ‡¶® ‡¶™‡ßã‡¶∏‡ßç‡¶ü ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßÅ‡¶® (admin only)"), 
        BotCommand("post", "Manage Channels & Posts (admin only)"),
        BotCommand("id", "Get Channel/File ID (admin only)"),
        BotCommand("mode_check", "‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶® ‡¶Æ‡ßã‡¶° ‡¶∏‡ßç‡¶ü‡ßç‡¶Ø‡¶æ‡¶ü‡¶æ‡¶∏ ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡ßÅ‡¶® (admin only)"), 
        BotCommand("broadcast", "‡¶¨‡ßç‡¶∞‡¶°‡¶ï‡¶æ‡¶∏‡ßç‡¶ü (‡¶ï‡ßá‡¶¨‡¶≤ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶°‡¶Æ‡¶ø‡¶®)"),
        BotCommand("help", "‡¶∏‡¶π‡¶æ‡¶Ø‡¶º‡¶ø‡¶ï‡¶æ")
    ]
    try:
        await app.set_bot_commands(cmds)
    except Exception as e:
        logger.warning("Set commands error: %s", e)

async def sequential_upload_task(uid, client, message, tmp_path, renamed_file, status_msg_id, cancel_event):
    if uid not in USER_UPLOAD_LOCKS:
        USER_UPLOAD_LOCKS[uid] = asyncio.Lock()
    
    async with USER_UPLOAD_LOCKS[uid]:
        if cancel_event.is_set():
            if tmp_path.exists(): tmp_path.unlink()
            return
        await process_file_and_upload(client, message, tmp_path, original_name=renamed_file, messages_to_delete=[status_msg_id], cancel_event_passed=cancel_event)

# --- QUEUE WORKER ---
async def process_queue_handler(uid, client):
    queue = USER_QUEUES[uid]
    while not queue.empty():
        task_data = await queue.get()
        try:
            m = task_data.get('message')
            original_name = task_data.get('original_name')
            status_msg = task_data.get('status_msg') 
            
            file_info = m.video or m.document
            
            cancel_event = asyncio.Event()
            TASKS.setdefault(uid, []).append(cancel_event)

            tmp_path = TMP / f"forwarded_{uid}_{int(datetime.now().timestamp())}_{original_name}"
            
            try:
                if status_msg:
                    try:
                        await status_msg.edit("‡¶°‡¶æ‡¶â‡¶®‡¶≤‡ßã‡¶° ‡¶π‡¶ö‡ßç‡¶õ‡ßá...", reply_markup=progress_keyboard())
                    except: pass
                
                await m.download(file_name=str(tmp_path))
                
                if cancel_event.is_set():
                     if tmp_path.exists(): tmp_path.unlink()
                     TASKS[uid].remove(cancel_event)
                     continue

                try:
                    if status_msg:
                        await status_msg.edit("‡¶°‡¶æ‡¶â‡¶®‡¶≤‡ßã‡¶° ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶®, Telegram-‡¶è ‡¶Ü‡¶™‡¶≤‡ßã‡¶° ‡¶π‡¶ö‡ßç‡¶õ‡ßá...", reply_markup=None)
                except Exception:
                    pass

                renamed_file = generate_new_filename(original_name)
                
                asyncio.create_task(
                    sequential_upload_task(uid, client, m, tmp_path, renamed_file, status_msg.id if status_msg else None, cancel_event)
                )
            
            except Exception as e:
                logger.error(f"Queue Item Failed: {e}")
                if status_msg:
                    await status_msg.edit(f"Queue Error: {e}")
                else:
                    await m.reply_text(f"Queue Error for `{original_name}`: {e}")
                if tmp_path.exists():
                    tmp_path.unlink()
            finally:
                pass

        except Exception as e:
            logger.error(f"Queue Loop Error: {e}")
        finally:
            queue.task_done()
    
    del USER_WORKERS[uid]
    del USER_QUEUES[uid]

# ---- handlers ----
@app.on_message(filters.command("start") & filters.private)
async def start_handler(c, m: Message):
    await set_bot_commands()
    SUBSCRIBERS.add(m.chat.id)
    text = (
        "Hi! ‡¶Ü‡¶Æ‡¶ø URL uploader bot.\n\n"
        "‡¶®‡ßã‡¶ü: ‡¶¨‡¶ü‡ßá‡¶∞ ‡¶Ö‡¶®‡ßá‡¶ï ‡¶ï‡¶Æ‡¶æ‡¶®‡ßç‡¶° ‡¶∂‡ßÅ‡¶ß‡ßÅ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶°‡¶Æ‡¶ø‡¶® (owner) ‡¶ö‡¶æ‡¶≤‡¶æ‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶¨‡ßá‡•§\n\n"
        "Commands:\n"
        "/upload_url <url> - URL ‡¶•‡ßá‡¶ï‡ßá ‡¶´‡¶æ‡¶á‡¶≤ ‡¶°‡¶æ‡¶â‡¶®‡¶≤‡ßã‡¶° ‡¶ì Telegram-‡¶è ‡¶Ü‡¶™‡¶≤‡ßã‡¶° (admin only)\n"
        "/setthumb - ‡¶è‡¶ï‡¶ü‡¶ø ‡¶õ‡¶¨‡¶ø ‡¶™‡¶æ‡¶†‡¶æ‡¶®, ‡¶∏‡ßá‡¶ü ‡¶π‡¶¨‡ßá ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶•‡¶æ‡¶Æ‡ßç‡¶¨‡¶®‡ßá‡¶á‡¶≤ (admin only)\n"
        "/view_thumb - ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶•‡¶æ‡¶Æ‡ßç‡¶¨‡¶®‡ßá‡¶á‡¶≤ ‡¶¶‡ßá‡¶ñ‡ßÅ‡¶® (admin only)\n"
        "/del_thumb - ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶•‡¶æ‡¶Æ‡ßç‡¶¨‡¶®‡ßá‡¶á‡¶≤ ‡¶Æ‡ßÅ‡¶õ‡ßá ‡¶´‡ßá‡¶≤‡ßÅ‡¶® (admin only)\n"
        "/set_caption - ‡¶è‡¶ï‡¶ü‡¶ø ‡¶ï‡ßç‡¶Ø‡¶æ‡¶™‡¶∂‡¶® ‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶® (admin only)\n"
        "/view_caption - ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶ï‡ßç‡¶Ø‡¶æ‡¶™‡¶∂‡¶® ‡¶¶‡ßá‡¶ñ‡ßÅ‡¶® (admin only)\n"
        "/edit_caption_mode - ‡¶∂‡ßÅ‡¶ß‡ßÅ ‡¶ï‡ßç‡¶Ø‡¶æ‡¶™‡¶∂‡¶® ‡¶è‡¶°‡¶ø‡¶ü ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶Æ‡ßã‡¶° ‡¶ü‡¶ó‡¶≤ ‡¶ï‡¶∞‡ßÅ‡¶® (admin only)\n"
        "/rename <newname.ext> - reply ‡¶ï‡¶∞‡¶æ ‡¶≠‡¶ø‡¶°‡¶ø‡¶ì ‡¶∞‡¶ø‡¶®‡ßá‡¶Æ ‡¶ï‡¶∞‡ßÅ‡¶® (admin only)\n"
        "/mkv_video_audio_change - MKV ‡¶≠‡¶ø‡¶°‡¶ø‡¶ì‡¶∞ ‡¶Ö‡¶°‡¶ø‡¶ì ‡¶ü‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶Æ‡ßã‡¶° ‡¶ü‡¶ó‡¶≤ ‡¶ï‡¶∞‡ßÅ‡¶® (admin only)\n"
        "/create_post - ‡¶®‡¶§‡ßÅ‡¶® ‡¶™‡ßã‡¶∏‡ßç‡¶ü ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßÅ‡¶® (admin only)\n" 
        "/post - Manage Channels and Create Button Posts (admin only)\n"
        "/id - Get Channel/File ID (admin only)\n"
        "/mode_check - ‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶® ‡¶Æ‡ßã‡¶° ‡¶∏‡ßç‡¶ü‡ßç‡¶Ø‡¶æ‡¶ü‡¶æ‡¶∏ ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡ßÅ‡¶® ‡¶è‡¶¨‡¶Ç ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶ï‡¶∞‡ßÅ‡¶® (admin only)\n" 
        "/broadcast <text> - ‡¶¨‡ßç‡¶∞‡¶°‡¶ï‡¶æ‡¶∏‡ßç‡¶ü (‡¶∂‡ßÅ‡¶ß‡ßÅ‡¶Æ‡¶æ‡¶§‡ßç‡¶∞ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶°‡¶Æ‡¶ø‡¶®)\n"
        "/help - ‡¶∏‡¶æ‡¶π‡¶æ‡¶Ø‡ßç‡¶Ø"
    )
    await m.reply_text(text)

@app.on_message(filters.command("help") & filters.private)
async def help_handler(c, m):
    await start_handler(c, m)

# --- NEW: /post Command Handler ---
@app.on_message(filters.command("post") & admin_filter)
async def post_command(client, message):
    user_data[message.from_user.id] = {"state": STATE_IDLE}
    markup = InlineKeyboardMarkup([
        [InlineKeyboardButton("Save Channel", callback_data="mode_save_channel"),
         InlineKeyboardButton("Edit Post", callback_data="mode_edit_post")],
        [InlineKeyboardButton("Create New Post", callback_data="mode_create_post")]
    ])
    await message.reply("Select an option:", reply_markup=markup)

# --- NEW: /id Command Handler ---
@app.on_message(filters.command("id") & admin_filter)
async def id_command_handler(client, message):
    user_data[message.from_user.id] = {"state": STATE_AWAIT_ID_FORWARD}
    await message.reply("Please forward a message from a Channel or Group to get IDs.")

# --- NEW: Callbacks for Post Bot ---
@app.on_callback_query(filters.regex(r"^(mode_|edit_|cancel$|cancel_to_|skip_|send_to_)"))
async def post_callback_handler(client, callback: CallbackQuery):
    uid = callback.from_user.id
    if not is_admin(uid): return
    data = callback.data
    if uid not in user_data: user_data[uid] = {}

    if data == "cancel":
        user_data[uid] = {"state": STATE_IDLE}
        await callback.message.edit_text("Operation Cancelled.")
    
    elif data == "cancel_to_edit_menu":
        user_data[uid]["state"] = STATE_EDIT_MENU
        await callback.message.edit_text("Edit Menu. Select what to change:", reply_markup=get_edit_menu_markup())

    elif data == "mode_save_channel":
        user_data[uid]["state"] = STATE_AWAIT_FORWARD_SAVE
        await callback.message.edit_text("Forward a message from the channel to save it.", reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Cancel", callback_data="cancel")]]))

    elif data == "mode_edit_post":
        user_data[uid]["state"] = STATE_AWAIT_FORWARD_EDIT
        await callback.message.edit_text("Forward the message from the channel you want to edit.", reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Cancel", callback_data="cancel")]]))

    elif data == "mode_create_post":
        user_data[uid] = {"state": STATE_AWAIT_MEDIA}
        await callback.message.edit_text("Send or Forward an Image or Video.", reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Cancel", callback_data="cancel")]]))

    elif data == "skip_caption":
        user_data[uid]["caption"] = ""
        user_data[uid]["state"] = STATE_AWAIT_BUTTONS
        await callback.message.edit_text("No caption. Send Button Format now.", reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Cancel", callback_data="cancel")]]))

    elif data.startswith("send_to_"):
        cid = data.split("send_to_")[1]
        target_channels = list(saved_channels.keys()) if cid == "all" else [cid]
        dt = user_data[uid]
        media, caption, buttons = dt.get("media"), dt.get("caption"), parse_buttons(dt.get("buttons_text"))
        
        await callback.message.edit_text("Sending...")
        for chat_id in target_channels:
            try:
                if media:
                    if hasattr(media, 'photo') and media.photo:
                        await client.send_photo(int(chat_id), media.photo.file_id, caption=caption, reply_markup=buttons, parse_mode=ParseMode.HTML)
                    elif hasattr(media, 'video') and media.video:
                        await client.send_video(int(chat_id), media.video.file_id, caption=caption, reply_markup=buttons, parse_mode=ParseMode.HTML)
                else:
                    await client.send_message(int(chat_id), caption, reply_markup=buttons, parse_mode=ParseMode.HTML)
            except Exception as e: 
                logger.error(f"Failed to send to {chat_id}: {e}")
        await callback.message.edit_text("Post Sent!")
        # Reset state
        user_data[uid] = {"state": STATE_IDLE}

    elif data == "edit_change_media":
        user_data[uid]["state"] = STATE_EDIT_NEW_MEDIA
        await callback.message.edit_text("Send new Image/Video:", reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Cancel", callback_data="cancel_to_edit_menu")]]))

    elif data == "edit_change_caption":
        user_data[uid]["state"] = STATE_EDIT_NEW_CAPTION
        await callback.message.edit_text("Send new Caption (Long press for formatting):", reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Cancel", callback_data="cancel_to_edit_menu")]]))

    elif data == "edit_change_buttons":
        user_data[uid]["state"] = STATE_EDIT_NEW_BUTTONS
        await callback.message.edit_text("Send new Button Format:", reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Cancel", callback_data="cancel_to_edit_menu")]]))

    elif data == "edit_update_final":
        dt = user_data[uid]
        try:
            cap = dt.get("new_caption") if "new_caption" in dt else dt.get("orig_caption", "")
            btns = parse_buttons(dt["new_buttons_text"]) if "new_buttons_text" in dt else dt.get("orig_markup")
            media = dt.get("new_media")
            if media:
                input_media = InputMediaPhoto(media.photo.file_id, caption=cap, parse_mode=ParseMode.HTML) if media.photo else InputMediaVideo(media.video.file_id, caption=cap, parse_mode=ParseMode.HTML)
                await client.edit_message_media(int(dt["target_channel_id"]), int(dt["target_msg_id"]), media=input_media, reply_markup=btns)
            else:
                await client.edit_message_caption(int(dt["target_channel_id"]), int(dt["target_msg_id"]), caption=cap, reply_markup=btns, parse_mode=ParseMode.HTML)
            await callback.message.edit_text("Post Updated!")
            user_data[uid]["state"] = STATE_IDLE
        except Exception as e: await callback.message.edit_text(f"Error: {e}")

# --- Callback for Admin ID Button ---
@app.on_callback_query(filters.regex("^show_admin_id"))
async def show_admin_id_callback(client, callback: CallbackQuery):
    if not is_admin(callback.from_user.id): return
    await callback.answer(f"Your Admin ID: {callback.from_user.id}", show_alert=True)

# --- NEW: State Machine Handler for Post Bot ---
# This handler runs before the general text_handler to capture input when in a specific state
@app.on_message(admin_filter, group=-1)
async def post_state_handler(client, message: Message):
    uid = message.from_user.id
    if uid not in user_data: return
    state = user_data[uid].get("state")
    
    if state == STATE_IDLE:
        return # Let other handlers process it

    # Process states
    if state == STATE_AWAIT_FORWARD_SAVE:
        if message.forward_from_chat:
            saved_channels[str(message.forward_from_chat.id)] = message.forward_from_chat.title
            save_channels(saved_channels)
            await message.reply(f"Saved: {message.forward_from_chat.title}")
            user_data[uid]["state"] = STATE_IDLE
            message.stop_propagation()
        else: await message.reply("Forward from a channel.")

    elif state == STATE_AWAIT_MEDIA:
        if message.photo or message.video:
            user_data[uid]["media"] = message
            if message.forward_date or not message.caption:
                user_data[uid]["caption"] = ""
                await message.reply("Media Saved. Please send a Caption.", reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("No Caption", callback_data="skip_caption")]]))
                user_data[uid]["state"] = STATE_AWAIT_CAPTION
            else:
                user_data[uid]["caption"] = message.caption.html
                await message.reply("Caption Saved. Send Button Format now.", reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Cancel", callback_data="cancel")]]))
                user_data[uid]["state"] = STATE_AWAIT_BUTTONS
            message.stop_propagation()

    elif state == STATE_AWAIT_CAPTION:
        user_data[uid]["caption"] = message.text.html if message.text else message.caption.html
        user_data[uid]["state"] = STATE_AWAIT_BUTTONS
        await message.reply("Caption Saved. Send Button Format now.", reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Cancel", callback_data="cancel")]]))
        message.stop_propagation()

    elif state == STATE_AWAIT_BUTTONS:
        user_data[uid]["buttons_text"] = message.text
        btns = [[InlineKeyboardButton(n, callback_data=f"send_to_{c}")] for c, n in saved_channels.items()]
        btns.append([InlineKeyboardButton("Send to All", callback_data="send_to_all")])
        btns.append([InlineKeyboardButton("Cancel", callback_data="cancel")])
        await message.reply("Ready! Select target:", reply_markup=InlineKeyboardMarkup(btns))
        message.stop_propagation()

    elif state == STATE_AWAIT_FORWARD_EDIT:
        if message.forward_from_chat:
            t_cid, t_mid = message.forward_from_chat.id, message.forward_from_message_id
            try:
                orig = await client.get_messages(t_cid, t_mid)
                user_data[uid].update({"target_channel_id": t_cid, "target_msg_id": t_mid, "orig_caption": orig.caption.html if orig.caption else "", "orig_markup": orig.reply_markup})
                for k in ["new_caption", "new_buttons_text", "new_media"]: user_data[uid].pop(k, None)
                await message.reply("Edit Menu. Select what to change:", reply_markup=get_edit_menu_markup())
                user_data[uid]["state"] = STATE_EDIT_MENU
            except Exception as e: await message.reply(f"Error: {e}")
            message.stop_propagation()
        else: await message.reply("Forward from the channel.")

    elif state == STATE_EDIT_NEW_MEDIA:
        if message.photo or message.video:
            user_data[uid]["new_media"] = message
            await message.reply("Media Updated. What next?", reply_markup=get_edit_menu_markup())
            user_data[uid]["state"] = STATE_EDIT_MENU
            message.stop_propagation()
            
    elif state == STATE_EDIT_NEW_CAPTION:
        user_data[uid]["new_caption"] = message.text.html if message.text else message.caption.html
        await message.reply("Caption Updated. What next?", reply_markup=get_edit_menu_markup())
        user_data[uid]["state"] = STATE_EDIT_MENU
        message.stop_propagation()

    elif state == STATE_EDIT_NEW_BUTTONS:
        user_data[uid]["new_buttons_text"] = message.text
        await message.reply("Buttons Updated. What next?", reply_markup=get_edit_menu_markup())
        user_data[uid]["state"] = STATE_EDIT_MENU
        message.stop_propagation()

    elif state == STATE_AWAIT_ID_FORWARD:
        chat_id = "N/A"
        chat_title = "N/A"
        if message.forward_from_chat:
            chat_id = message.forward_from_chat.id
            chat_title = message.forward_from_chat.title
        elif message.forward_from:
            chat_id = message.forward_from.id
            chat_title = message.forward_from.first_name
        
        file_id = "No Media"
        if message.video: file_id = message.video.file_id
        elif message.document: file_id = message.document.file_id
        elif message.photo: file_id = message.photo.file_id
        elif message.audio: file_id = message.audio.file_id
        elif message.voice: file_id = message.voice.file_id
        elif message.animation: file_id = message.animation.file_id
        elif message.sticker: file_id = message.sticker.file_id

        text = f"**Source ID:** `{chat_id}`\n**Source Title:** {chat_title}\n**File ID:** `{file_id}`"
        markup = InlineKeyboardMarkup([[InlineKeyboardButton("Admin Id", callback_data="show_admin_id")]])
        
        await message.reply(text, reply_markup=markup, parse_mode=ParseMode.MARKDOWN)
        user_data[uid]["state"] = STATE_IDLE
        message.stop_propagation()

# -----------------------------------------------

@app.on_message(filters.command("setthumb") & filters.private)
async def setthumb_prompt(c, m):
    if not is_admin(m.from_user.id):
        await m.reply_text("‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ö‡¶®‡ßÅ‡¶Æ‡¶§‡¶ø ‡¶®‡ßá‡¶á ‡¶è‡¶á ‡¶ï‡¶Æ‡¶æ‡¶®‡ßç‡¶° ‡¶ö‡¶æ‡¶≤‡¶æ‡¶®‡ßã‡¶∞‡•§")
        return
    
    uid = m.from_user.id
    if len(m.command) > 1:
        time_str = " ".join(m.command[1:])
        seconds = parse_time(time_str)
        if seconds > 0:
            USER_THUMB_TIME[uid] = seconds
            await m.reply_text(f"‡¶•‡¶æ‡¶Æ‡ßç‡¶¨‡¶®‡ßá‡¶á‡¶≤ ‡¶§‡ßà‡¶∞‡¶ø‡¶∞ ‡¶∏‡¶Æ‡¶Ø‡¶º ‡¶∏‡ßá‡¶ü ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá: {seconds} ‡¶∏‡ßá‡¶ï‡ßá‡¶®‡ßç‡¶°‡•§")
        else:
            await m.reply_text("‡¶∏‡¶†‡¶ø‡¶ï ‡¶´‡¶∞‡¶Æ‡ßç‡¶Ø‡¶æ‡¶ü‡ßá ‡¶∏‡¶Æ‡¶Ø‡¶º ‡¶¶‡¶ø‡¶®‡•§ ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£: `/setthumb 5s`, `/setthumb 1m`, `/setthumb 1m 30s`")
    else:
        SET_THUMB_REQUEST.add(uid)
        await m.reply_text("‡¶è‡¶ï‡¶ü‡¶ø ‡¶õ‡¶¨‡¶ø ‡¶™‡¶æ‡¶†‡¶æ‡¶® (photo) ‚Äî ‡¶∏‡ßá‡¶ü ‡¶π‡¶¨‡ßá ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶•‡¶æ‡¶Æ‡ßç‡¶¨‡¶®‡ßá‡¶á‡¶≤‡•§")


@app.on_message(filters.command("view_thumb") & filters.private)
async def view_thumb_cmd(c, m: Message):
    if not is_admin(m.from_user.id):
        await m.reply_text("‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ö‡¶®‡ßÅ‡¶Æ‡¶§‡¶ø ‡¶®‡ßá‡¶á ‡¶è‡¶á ‡¶ï‡¶Æ‡¶æ‡¶®‡ßç‡¶° ‡¶ö‡¶æ‡¶≤‡¶æ‡¶®‡ßã‡¶∞‡•§")
        return
    uid = m.from_user.id
    thumb_path = USER_THUMBS.get(uid)
    thumb_time = USER_THUMB_TIME.get(uid)
    
    if thumb_path and Path(thumb_path).exists():
        await c.send_photo(chat_id=m.chat.id, photo=thumb_path, caption="‡¶è‡¶ü‡¶æ ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶∏‡ßá‡¶≠ ‡¶ï‡¶∞‡¶æ ‡¶•‡¶æ‡¶Æ‡ßç‡¶¨‡¶®‡ßá‡¶á‡¶≤‡•§")
    elif thumb_time:
        await m.reply_text(f"‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶•‡¶æ‡¶Æ‡ßç‡¶¨‡¶®‡ßá‡¶á‡¶≤ ‡¶§‡ßà‡¶∞‡¶ø‡¶∞ ‡¶∏‡¶Æ‡¶Ø‡¶º ‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶Ü‡¶õ‡ßá: {thumb_time} ‡¶∏‡ßá‡¶ï‡ßá‡¶®‡ßç‡¶°‡•§")
    else:
        await m.reply_text("‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶ï‡ßã‡¶®‡ßã ‡¶•‡¶æ‡¶Æ‡ßç‡¶¨‡¶®‡ßá‡¶á‡¶≤ ‡¶¨‡¶æ ‡¶•‡¶æ‡¶Æ‡ßç‡¶¨‡¶®‡ßá‡¶á‡¶≤ ‡¶§‡ßà‡¶∞‡¶ø‡¶∞ ‡¶∏‡¶Æ‡¶Ø‡¶º ‡¶∏‡ßá‡¶≠ ‡¶ï‡¶∞‡¶æ ‡¶®‡ßá‡¶á‡•§ /setthumb ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶®‡•§")

@app.on_message(filters.command("del_thumb") & filters.private)
async def del_thumb_cmd(c, m: Message):
    if not is_admin(m.from_user.id):
        await m.reply_text("‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ö‡¶®‡ßÅ‡¶Æ‡¶§‡¶ø ‡¶®‡ßá‡¶á ‡¶è‡¶á ‡¶ï‡¶Æ‡¶æ‡¶®‡ßç‡¶° ‡¶ö‡¶æ‡¶≤‡¶æ‡¶®‡ßã‡¶∞‡•§")
        return
    uid = m.from_user.id
    thumb_path = USER_THUMBS.get(uid)
    if thumb_path and Path(thumb_path).exists():
        try:
            Path(thumb_path).unlink()
        except Exception:
            pass
        USER_THUMBS.pop(uid, None)
    
    if uid in USER_THUMB_TIME:
        USER_THUMB_TIME.pop(uid)

    if not (thumb_path or uid in USER_THUMB_TIME):
        await m.reply_text("‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶ï‡ßã‡¶®‡ßã ‡¶•‡¶æ‡¶Æ‡ßç‡¶¨‡¶®‡ßá‡¶á‡¶≤ ‡¶∏‡ßá‡¶≠ ‡¶ï‡¶∞‡¶æ ‡¶®‡ßá‡¶á‡•§")
    else:
        await m.reply_text("‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶•‡¶æ‡¶Æ‡ßç‡¶¨‡¶®‡ßá‡¶á‡¶≤/‡¶•‡¶æ‡¶Æ‡ßç‡¶¨‡¶®‡ßá‡¶á‡¶≤ ‡¶§‡ßà‡¶∞‡¶ø‡¶∞ ‡¶∏‡¶Æ‡¶Ø‡¶º ‡¶Æ‡ßÅ‡¶õ‡ßá ‡¶´‡ßá‡¶≤‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§")


@app.on_message(filters.photo & filters.private)
async def photo_handler(c, m: Message):
    if not is_admin(m.from_user.id):
        return
    uid = m.from_user.id
    
    if uid in CREATE_POST_MODE and uid in POST_CREATION_STATE and POST_CREATION_STATE[uid]['state'] == 'awaiting_image':
        
        state_data = POST_CREATION_STATE[uid]
        state_data['message_ids'].append(m.id) 
        
        out = TMP / f"post_img_{uid}.jpg"
        try:
            download_msg = await m.reply_text("‡¶õ‡¶¨‡¶ø ‡¶°‡¶æ‡¶â‡¶®‡¶≤‡ßã‡¶° ‡¶π‡¶ö‡ßç‡¶õ‡ßá...")
            state_data['message_ids'].append(download_msg.id)
            
            await m.download(file_name=str(out))
            img = Image.open(out)
            img.thumbnail((1080, 1080)) 
            img = img.convert("RGB")
            img.save(out, "JPEG")
            
            state_data['image_path'] = str(out)
            state_data['state'] = 'awaiting_name_change'
            
            initial_caption = generate_post_caption(state_data['post_data'])
            
            post_msg = await c.send_photo(
                chat_id=m.chat.id, 
                photo=str(out), 
                caption=initial_caption, 
                parse_mode=ParseMode.MARKDOWN
            )
            state_data['post_message_id'] = post_msg.id 
            state_data['message_ids'].append(post_msg.id) 
            
            prompt_msg = await m.reply_text(
                f"‚úÖ ‡¶™‡ßã‡¶∏‡ßç‡¶ü‡ßá‡¶∞ ‡¶õ‡¶¨‡¶ø ‡¶∏‡ßá‡¶ü ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§\n\n**‡¶è‡¶ñ‡¶® ‡¶õ‡¶¨‡¶ø‡¶∞ ‡¶®‡¶æ‡¶Æ‡¶ü‡¶ø ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®‡•§**\n"
                f"‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶® ‡¶®‡¶æ‡¶Æ: `{state_data['post_data']['image_name']}`\n"
                f"‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶∂‡ßÅ‡¶ß‡ßÅ **‡¶®‡¶æ‡¶Æ‡¶ü‡¶ø** ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡•§ ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£: `One Piece`"
            )
            state_data['message_ids'].append(prompt_msg.id)

        except Exception as e:
            logger.error(f"Post creation image error: {e}")
            await m.reply_text(f"‡¶õ‡¶¨‡¶ø ‡¶∏‡ßá‡¶≠ ‡¶ï‡¶∞‡¶§‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ: {e}")
            CREATE_POST_MODE.discard(uid)
            POST_CREATION_STATE.pop(uid, None)
            if out.exists(): out.unlink(missing_ok=True)
        return
    
    if uid in SET_THUMB_REQUEST:
        SET_THUMB_REQUEST.discard(uid)
        out = TMP / f"thumb_{uid}.jpg"
        try:
            await m.download(file_name=str(out))
            img = Image.open(out)
            img.thumbnail((320, 320))
            img = img.convert("RGB")
            img.save(out, "JPEG")
            USER_THUMBS[uid] = str(out)
            USER_THUMB_TIME.pop(uid, None)
            await m.reply_text("‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶•‡¶æ‡¶Æ‡ßç‡¶¨‡¶®‡ßá‡¶á‡¶≤ ‡¶∏‡ßá‡¶≠ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§")
        except Exception as e:
            await m.reply_text(f"‡¶•‡¶æ‡¶Æ‡ßç‡¶¨‡¶®‡ßá‡¶á‡¶≤ ‡¶∏‡ßá‡¶≠ ‡¶ï‡¶∞‡¶§‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ: {e}")
    else:
        pass

@app.on_message(filters.command("set_caption") & filters.private)
async def set_caption_prompt(c, m: Message):
    if not is_admin(m.from_user.id):
        await m.reply_text("‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ö‡¶®‡ßÅ‡¶Æ‡¶§‡¶ø ‡¶®‡ßá‡¶á ‡¶è‡¶á ‡¶ï‡¶Æ‡¶æ‡¶®‡ßç‡¶° ‡¶ö‡¶æ‡¶≤‡¶æ‡¶®‡ßã‡¶∞‡•§")
        return
    SET_CAPTION_REQUEST.add(m.from_user.id)
    USER_COUNTERS.pop(m.from_user.id, None)
    
    await m.reply_text(
        "‡¶ï‡ßç‡¶Ø‡¶æ‡¶™‡¶∂‡¶® ‡¶¶‡¶ø‡¶®‡•§ ‡¶è‡¶ñ‡¶® ‡¶Ü‡¶™‡¶®‡¶ø ‡¶è‡¶á ‡¶ï‡ßã‡¶°‡¶ó‡ßÅ‡¶≤‡ßã ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶¨‡ßá‡¶®:\n"
        "1. **‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶¨‡ßÉ‡¶¶‡ßç‡¶ß‡¶ø:** `[01]`, `[(01)]` (‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶∏‡ßç‡¶¨‡¶Ø‡¶º‡¶Ç‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶≠‡¶æ‡¶¨‡ßá ‡¶¨‡¶æ‡¶°‡¶º‡¶¨‡ßá)\n"
        "2. **‡¶ó‡ßÅ‡¶£‡¶Æ‡¶æ‡¶®‡ßá‡¶∞ ‡¶∏‡¶æ‡¶á‡¶ï‡ßá‡¶≤:** `[re (480p, 720p)]`\n"
        "3. **‡¶∂‡¶∞‡ßç‡¶§‡¶∏‡¶æ‡¶™‡ßá‡¶ï‡ßç‡¶∑ ‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü (‡¶®‡¶§‡ßÅ‡¶®):** `[TEXT (XX)]` - ‡¶Ø‡ßá‡¶Æ‡¶®: `[End (02)]`, `[hi (05)]` (‡¶Ø‡¶¶‡¶ø ‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶® ‡¶™‡¶∞‡ßç‡¶¨‡ßá‡¶∞ ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ `XX` ‡¶è‡¶∞ **‡¶∏‡¶Æ‡¶æ‡¶®** ‡¶π‡ßü, ‡¶§‡¶æ‡¶π‡¶≤‡ßá `TEXT` ‡¶Ø‡ßã‡¶ó ‡¶π‡¶¨‡ßá)‡•§"
    )

@app.on_message(filters.command("view_caption") & filters.private)
async def view_caption_cmd(c, m: Message):
    if not is_admin(m.from_user.id):
        await m.reply_text("‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ö‡¶®‡ßÅ‡¶Æ‡¶§‡¶ø ‡¶®‡ßá‡¶á ‡¶è‡¶á ‡¶ï‡¶Æ‡¶æ‡¶®‡ßç‡¶° ‡¶ö‡¶æ‡¶≤‡¶æ‡¶®‡ßã‡¶∞‡•§")
        return
    uid = m.from_user.id
    caption = USER_CAPTIONS.get(uid)
    if caption:
        await m.reply_text(f"‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶∏‡ßá‡¶≠ ‡¶ï‡¶∞‡¶æ ‡¶ï‡ßç‡¶Ø‡¶æ‡¶™‡¶∂‡¶®:\n\n`{caption}`", reply_markup=delete_caption_keyboard())
    else:
        await m.reply_text("‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶ï‡ßã‡¶®‡ßã ‡¶ï‡ßç‡¶Ø‡¶æ‡¶™‡¶∂‡¶® ‡¶∏‡ßá‡¶≠ ‡¶ï‡¶∞‡¶æ ‡¶®‡ßá‡¶á‡•§ /set_caption ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶®‡•§")

@app.on_callback_query(filters.regex("delete_caption"))
async def delete_caption_cb(c, cb):
    uid = cb.from_user.id
    if not is_admin(uid):
        await cb.answer("‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ö‡¶®‡ßÅ‡¶Æ‡¶§‡¶ø ‡¶®‡ßá‡¶á‡•§", show_alert=True)
        return
    if uid in USER_CAPTIONS:
        USER_CAPTIONS.pop(uid)
        USER_COUNTERS.pop(uid, None) 
        await cb.message.edit_text("‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶ï‡ßç‡¶Ø‡¶æ‡¶™‡¶∂‡¶® ‡¶Æ‡ßÅ‡¶õ‡ßá ‡¶´‡ßá‡¶≤‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§")
    else:
        await cb.answer("‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶ï‡ßã‡¶®‡ßã ‡¶ï‡ßç‡¶Ø‡¶æ‡¶™‡¶∂‡¶® ‡¶∏‡ßá‡¶≠ ‡¶ï‡¶∞‡¶æ ‡¶®‡ßá‡¶á‡•§", show_alert=True)

@app.on_message(filters.command("edit_caption_mode") & filters.private)
async def toggle_edit_caption_mode(c, m: Message):
    uid = m.from_user.id
    if not is_admin(uid):
        await m.reply_text("‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ö‡¶®‡ßÅ‡¶Æ‡¶§‡¶ø ‡¶®‡ßá‡¶á ‡¶è‡¶á ‡¶ï‡¶Æ‡¶æ‡¶®‡ßç‡¶° ‡¶ö‡¶æ‡¶≤‡¶æ‡¶®‡ßã‡¶∞‡•§")
        return

    if uid in EDIT_CAPTION_MODE:
        EDIT_CAPTION_MODE.discard(uid)
        if uid in BATCH_CAPTION_MODE:
            BATCH_CAPTION_MODE.discard(uid)
            BATCH_DATA.pop(uid, None)
            BATCH_STATUS_MSG.pop(uid, None)
        await m.reply_text("edit video caption mod **OFF**.\n‡¶è‡¶ñ‡¶® ‡¶•‡ßá‡¶ï‡ßá ‡¶Ü‡¶™‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡¶æ ‡¶≠‡¶ø‡¶°‡¶ø‡¶ì‡¶∞ ‡¶∞‡¶ø‡¶®‡ßá‡¶Æ ‡¶ì ‡¶•‡¶æ‡¶Æ‡ßç‡¶¨‡¶®‡ßá‡¶á‡¶≤ ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶π‡¶¨‡ßá, ‡¶è‡¶¨‡¶Ç ‡¶∏‡ßá‡¶≠ ‡¶ï‡¶∞‡¶æ ‡¶ï‡ßç‡¶Ø‡¶æ‡¶™‡¶∂‡¶® ‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§ ‡¶π‡¶¨‡ßá‡•§")
    else:
        EDIT_CAPTION_MODE.add(uid)
        await m.reply_text("edit video caption mod **ON**.\n‡¶è‡¶ñ‡¶® ‡¶•‡ßá‡¶ï‡ßá ‡¶∂‡ßÅ‡¶ß‡ßÅ ‡¶∏‡ßá‡¶≠ ‡¶ï‡¶∞‡¶æ ‡¶ï‡ßç‡¶Ø‡¶æ‡¶™‡¶∂‡¶® ‡¶≠‡¶ø‡¶°‡¶ø‡¶ì‡¶§‡ßá ‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§ ‡¶π‡¶¨‡ßá‡•§ ‡¶≠‡¶ø‡¶°‡¶ø‡¶ì‡¶∞ ‡¶®‡¶æ‡¶Æ ‡¶è‡¶¨‡¶Ç ‡¶•‡¶æ‡¶Æ‡ßç‡¶¨‡¶®‡ßá‡¶á‡¶≤ ‡¶è‡¶ï‡¶á ‡¶•‡¶æ‡¶ï‡¶¨‡ßá‡•§\n\n**New Feature:** ‡¶´‡¶æ‡¶á‡¶≤ ‡¶Ü‡¶á‡¶°‡¶ø ‡¶∏‡ßá‡¶≠ ‡¶Æ‡ßã‡¶° ‡¶Ö‡¶® ‡¶ï‡¶∞‡¶§‡ßá `on` ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶®‡•§ ‡¶Ö‡¶´ ‡¶ï‡¶∞‡¶§‡ßá `off` ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶®‡•§")

@app.on_message(filters.command("mkv_video_audio_change") & filters.private)
async def toggle_audio_change_mode(c, m: Message):
    uid = m.from_user.id
    if not is_admin(uid):
        await m.reply_text("‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ö‡¶®‡ßÅ‡¶Æ‡¶§‡¶ø ‡¶®‡ßá‡¶á ‡¶è‡¶á ‡¶ï‡¶Æ‡¶æ‡¶®‡ßç‡¶° ‡¶ö‡¶æ‡¶≤‡¶æ‡¶®‡ßã‡¶∞‡•§")
        return

    if uid in MKV_AUDIO_CHANGE_MODE:
        MKV_AUDIO_CHANGE_MODE.discard(uid)
        await m.reply_text("MKV ‡¶Ö‡¶°‡¶ø‡¶ì ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶Æ‡ßã‡¶° **‡¶Ö‡¶´** ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§")
    else:
        MKV_AUDIO_CHANGE_MODE.add(uid)
        await m.reply_text("MKV ‡¶Ö‡¶°‡¶ø‡¶ì ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶Æ‡ßã‡¶° **‡¶Ö‡¶®** ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§ ‡¶è‡¶ñ‡¶® ‡¶Ü‡¶™‡¶®‡¶ø ‡¶è‡¶ï‡¶ü‡¶ø **MKV ‡¶´‡¶æ‡¶á‡¶≤** ‡¶Ö‡¶•‡¶¨‡¶æ ‡¶Ö‡¶®‡ßç‡¶Ø ‡¶ï‡ßã‡¶®‡ßã **‡¶≠‡¶ø‡¶°‡¶ø‡¶ì ‡¶´‡¶æ‡¶á‡¶≤** ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡•§\n(‡¶è‡¶á ‡¶Æ‡ßã‡¶° ‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡ßÅ‡ßü‡¶æ‡¶≤‡¶ø ‡¶Ö‡¶´ ‡¶®‡¶æ ‡¶ï‡¶∞‡¶æ ‡¶™‡¶∞‡ßç‡¶Ø‡¶®‡ßç‡¶§ ‡¶ö‡¶æ‡¶≤‡ßÅ ‡¶•‡¶æ‡¶ï‡¶¨‡ßá‡•§)")

@app.on_message(filters.command("create_post") & filters.private)
async def toggle_create_post_mode(c, m: Message):
    uid = m.from_user.id
    if not is_admin(uid):
        await m.reply_text("‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ö‡¶®‡ßÅ‡¶Æ‡¶§‡¶ø ‡¶®‡ßá‡¶á ‡¶è‡¶á ‡¶ï‡¶Æ‡¶æ‡¶®‡ßç‡¶° ‡¶ö‡¶æ‡¶≤‡¶æ‡¶®‡ßã‡¶∞‡•§")
        return

    if uid in CREATE_POST_MODE:
        CREATE_POST_MODE.discard(uid)
        if uid in POST_CREATION_STATE:
            state_data = POST_CREATION_STATE.pop(uid)
            try:
                if state_data.get('image_path'):
                    Path(state_data['image_path']).unlink(missing_ok=True)
                messages_to_delete = state_data.get('message_ids', [])
                post_id = state_data.get('post_message_id')
                if post_id and post_id in messages_to_delete:
                    messages_to_delete.remove(post_id) 
                if messages_to_delete:
                    await c.delete_messages(m.chat.id, messages_to_delete)
            except Exception as e:
                logger.warning(f"Post mode OFF cleanup error: {e}")
                
        await m.reply_text("Create Post Mode **‡¶Ö‡¶´** ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§")
    else:
        CREATE_POST_MODE.add(uid)
        POST_CREATION_STATE[uid] = {
            'image_path': None, 
            'message_ids': [m.id], 
            'state': 'awaiting_image', 
            'post_data': DEFAULT_POST_DATA.copy(),
            'post_message_id': None
        }
        await m.reply_text("Create Post Mode **‡¶Ö‡¶®** ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§\n‡¶è‡¶ï‡¶ü‡¶ø ‡¶õ‡¶¨‡¶ø (**Photo**) ‡¶™‡¶æ‡¶†‡¶æ‡¶® ‡¶Ø‡¶æ ‡¶™‡ßã‡¶∏‡ßç‡¶ü‡ßá‡¶∞ ‡¶á‡¶Æ‡ßá‡¶ú ‡¶π‡¶ø‡¶∏‡ßá‡¶¨‡ßá ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶π‡¶¨‡ßá‡•§")

@app.on_message(filters.command("mode_check") & filters.private)
async def mode_check_cmd(c, m: Message):
    uid = m.from_user.id
    if not is_admin(uid):
        await m.reply_text("‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ö‡¶®‡ßÅ‡¶Æ‡¶§‡¶ø ‡¶®‡ßá‡¶á ‡¶è‡¶á ‡¶ï‡¶Æ‡¶æ‡¶®‡ßç‡¶° ‡¶ö‡¶æ‡¶≤‡¶æ‡¶®‡ßã‡¶∞‡•§")
        return
    
    audio_status = "‚úÖ ON" if uid in MKV_AUDIO_CHANGE_MODE else "‚ùå OFF"
    caption_status = "‚úÖ ON" if uid in EDIT_CAPTION_MODE else "‚ùå OFF"
    
    waiting_count = sum(1 for data in PENDING_AUDIO_ORDERS.values() if data['uid'] == uid)
    waiting_status_text = f"{waiting_count}‡¶ü‡¶ø ‡¶´‡¶æ‡¶á‡¶≤ ‡¶ü‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶Ö‡¶™‡ßá‡¶ï‡ßç‡¶∑‡¶æ ‡¶ï‡¶∞‡¶õ‡ßá‡•§" if waiting_count > 0 else "‡¶ï‡ßã‡¶®‡ßã ‡¶´‡¶æ‡¶á‡¶≤ ‡¶Ö‡¶™‡ßá‡¶ï‡ßç‡¶∑‡¶æ ‡¶ï‡¶∞‡¶õ‡ßá ‡¶®‡¶æ‡•§"
    
    status_text = (
        "ü§ñ **‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶® ‡¶Æ‡ßã‡¶° ‡¶∏‡ßç‡¶ü‡ßç‡¶Ø‡¶æ‡¶ü‡¶æ‡¶∏:**\n\n"
        f"1. **MKV Audio Change Mode:** `{audio_status}`\n"
        f"   - *‡¶ï‡¶æ‡¶ú:* ‡¶´‡¶∞‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶°/‡¶°‡¶æ‡¶â‡¶®‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡¶æ MKV/‡¶≠‡¶ø‡¶°‡¶ø‡¶ì ‡¶´‡¶æ‡¶á‡¶≤‡ßá‡¶∞ ‡¶Ö‡¶°‡¶ø‡¶ì ‡¶ü‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶ï‡¶∞‡ßá‡•§ (‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡ßÅ‡ßü‡¶æ‡¶≤‡¶ø ‡¶Ö‡¶´ ‡¶®‡¶æ ‡¶ï‡¶∞‡¶æ ‡¶™‡¶∞‡ßç‡¶Ø‡¶®‡ßç‡¶§ ON ‡¶•‡¶æ‡¶ï‡¶¨‡ßá)\n"
        f"   - *‡¶∏‡ßç‡¶ü‡ßç‡¶Ø‡¶æ‡¶ü‡¶æ‡¶∏:* {waiting_status_text}\n\n"
        f"2. **Edit Caption Mode:** `{caption_status}`\n"
        f"   - *‡¶ï‡¶æ‡¶ú:* ‡¶´‡¶∞‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶° ‡¶ï‡¶∞‡¶æ ‡¶≠‡¶ø‡¶°‡¶ø‡¶ì‡¶∞ ‡¶∞‡¶ø‡¶®‡ßá‡¶Æ ‡¶¨‡¶æ ‡¶•‡¶æ‡¶Æ‡ßç‡¶¨‡¶®‡ßá‡¶á‡¶≤ ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶®‡¶æ ‡¶ï‡¶∞‡ßá ‡¶∂‡ßÅ‡¶ß‡ßÅ ‡¶∏‡ßá‡¶≠ ‡¶ï‡¶∞‡¶æ ‡¶ï‡ßç‡¶Ø‡¶æ‡¶™‡¶∂‡¶® ‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§ ‡¶ï‡¶∞‡ßá‡•§\n\n"
        "‡¶®‡¶ø‡¶ö‡ßá‡¶∞ ‡¶¨‡¶æ‡¶ü‡¶®‡¶ó‡ßÅ‡¶≤‡¶ø‡¶§‡ßá ‡¶ï‡ßç‡¶≤‡¶ø‡¶ï ‡¶ï‡¶∞‡ßá ‡¶Æ‡ßã‡¶° ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®‡•§"
    )
    
    await m.reply_text(status_text, reply_markup=mode_check_keyboard(uid), parse_mode=ParseMode.MARKDOWN)

@app.on_callback_query(filters.regex("toggle_(audio|caption)_mode"))
async def mode_toggle_callback(c: Client, cb: CallbackQuery):
    uid = cb.from_user.id
    if not is_admin(uid):
        await cb.answer("‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ö‡¶®‡ßÅ‡¶Æ‡¶§‡¶ø ‡¶®‡ßá‡¶á‡•§", show_alert=True)
        return

    action = cb.data
    
    if action == "toggle_audio_mode":
        if uid in MKV_AUDIO_CHANGE_MODE:
            MKV_AUDIO_CHANGE_MODE.discard(uid)
            message = "MKV Audio Change Mode OFF."
        else:
            MKV_AUDIO_CHANGE_MODE.add(uid)
            message = "MKV Audio Change Mode ON."
            
    elif action == "toggle_caption_mode":
        if uid in EDIT_CAPTION_MODE:
            EDIT_CAPTION_MODE.discard(uid)
            message = "Edit Caption Mode OFF."
        else:
            EDIT_CAPTION_MODE.add(uid)
            message = "Edit Caption Mode ON."
            
    try:
        audio_status = "‚úÖ ON" if uid in MKV_AUDIO_CHANGE_MODE else "‚ùå OFF"
        caption_status = "‚úÖ ON" if uid in EDIT_CAPTION_MODE else "‚ùå OFF"
        
        waiting_count = sum(1 for data in PENDING_AUDIO_ORDERS.values() if data['uid'] == uid)
        waiting_status_text = f"{waiting_count}‡¶ü‡¶ø ‡¶´‡¶æ‡¶á‡¶≤ ‡¶ü‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶Ö‡¶™‡ßá‡¶ï‡ßç‡¶∑‡¶æ ‡¶ï‡¶∞‡¶õ‡ßá‡•§" if waiting_count > 0 else "‡¶ï‡ßã‡¶®‡ßã ‡¶´‡¶æ‡¶á‡¶≤ ‡¶Ö‡¶™‡ßá‡¶ï‡ßç‡¶∑‡¶æ ‡¶ï‡¶∞‡¶õ‡ßá ‡¶®‡¶æ‡•§"

        status_text = (
            "ü§ñ **‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶® ‡¶Æ‡ßã‡¶° ‡¶∏‡ßç‡¶ü‡ßç‡¶Ø‡¶æ‡¶ü‡¶æ‡¶∏:**\n\n"
            f"1. **MKV Audio Change Mode:** `{audio_status}`\n"
            f"   - *‡¶ï‡¶æ‡¶ú:* ‡¶´‡¶∞‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶°/‡¶°‡¶æ‡¶â‡¶®‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡¶æ MKV/‡¶≠‡¶ø‡¶°‡¶ø‡¶ì ‡¶´‡¶æ‡¶á‡¶≤‡ßá‡¶∞ ‡¶Ö‡¶°‡¶ø‡¶ì ‡¶ü‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶ï‡¶∞‡ßá‡•§ (‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡ßÅ‡ßü‡¶æ‡¶≤‡¶ø ‡¶Ö‡¶´ ‡¶®‡¶æ ‡¶ï‡¶∞‡¶æ ‡¶™‡¶∞‡ßç‡¶Ø‡¶®‡ßç‡¶§ ON ‡¶•‡¶æ‡¶ï‡¶¨‡ßá)\n"
            f"   - *‡¶∏‡ßç‡¶ü‡ßç‡¶Ø‡¶æ‡¶ü‡¶æ‡¶∏:* {waiting_status_text}\n\n"
            f"2. **Edit Caption Mode:** `{caption_status}`\n"
            f"   - *‡¶ï‡¶æ‡¶ú:* ‡¶´‡¶∞‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶° ‡¶ï‡¶∞‡¶æ ‡¶≠‡¶ø‡¶°‡¶ø‡¶ì‡¶∞ ‡¶∞‡¶ø‡¶®‡ßá‡¶Æ ‡¶¨‡¶æ ‡¶•‡¶æ‡¶Æ‡ßç‡¶¨‡¶®‡ßá‡¶á‡¶≤ ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶®‡¶æ ‡¶ï‡¶∞‡ßá ‡¶∂‡ßÅ‡¶ß‡ßÅ ‡¶∏‡ßá‡¶≠ ‡¶ï‡¶∞‡¶æ ‡¶ï‡ßç‡¶Ø‡¶æ‡¶™‡¶∂‡¶® ‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§ ‡¶ï‡¶∞‡ßá‡•§\n\n"
            "‡¶®‡¶ø‡¶ö‡ßá‡¶∞ ‡¶¨‡¶æ‡¶ü‡¶®‡¶ó‡ßÅ‡¶≤‡¶ø‡¶§‡ßá ‡¶ï‡ßç‡¶≤‡¶ø‡¶ï ‡¶ï‡¶∞‡ßá ‡¶Æ‡ßã‡¶° ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®‡•§"
        )
        
        await cb.message.edit_text(status_text, reply_markup=mode_check_keyboard(uid), parse_mode=ParseMode.MARKDOWN)
        await cb.answer(message, show_alert=True)
    except Exception as e:
        logger.error(f"Callback edit error: {e}")
        await cb.answer(message, show_alert=True)


@app.on_message(filters.text & filters.private)
async def text_handler(c, m: Message):
    uid = m.from_user.id
    if not is_admin(uid):
        return
    text = m.text.strip()
    
    if uid in EDIT_CAPTION_MODE:
        if text.lower() == "on":
            BATCH_CAPTION_MODE.add(uid)
            BATCH_DATA[uid] = []
            await m.reply_text("Batch Caption Mode ON. ‡¶è‡¶ñ‡¶® ‡¶≠‡¶ø‡¶°‡¶ø‡¶ì ‡¶´‡¶∞‡¶ì‡ßü‡¶æ‡¶∞‡ßç‡¶° ‡¶ï‡¶∞‡¶≤‡ßá ‡¶´‡¶æ‡¶á‡¶≤ ‡¶Ü‡¶á‡¶°‡¶ø ‡¶∏‡ßá‡¶≠ ‡¶π‡¶¨‡ßá‡•§")
            return
        elif text.lower() == "off":
            BATCH_CAPTION_MODE.discard(uid)
            BATCH_DATA.pop(uid, None)
            BATCH_STATUS_MSG.pop(uid, None)
            await m.reply_text("Batch Caption Mode OFF. ‡¶è‡¶ñ‡¶® ‡¶≠‡¶ø‡¶°‡¶ø‡¶ì ‡¶´‡¶∞‡¶ì‡ßü‡¶æ‡¶∞‡ßç‡¶° ‡¶ï‡¶∞‡¶≤‡ßá ‡¶∏‡¶∞‡¶æ‡¶∏‡¶∞‡¶ø ‡¶ï‡ßç‡¶Ø‡¶æ‡¶™‡¶∂‡¶® ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶π‡¶¨‡ßá‡•§")
            return
        elif text.lower() == "ok":
            if uid in BATCH_CAPTION_MODE and uid in BATCH_DATA and BATCH_DATA[uid]:
                items = BATCH_DATA[uid]
                await m.reply_text(f"Processing started for {len(items)} items...")
                
                for item in items:
                    msg_obj = item['message']
                    file_info_obj = item['file_info']
                    await handle_caption_only_upload_with_file(c, msg_obj, file_info_obj)
                    await asyncio.sleep(0.5)
                
                BATCH_DATA[uid] = []
                if uid in BATCH_STATUS_MSG:
                    try:
                        await c.delete_messages(m.chat.id, BATCH_STATUS_MSG[uid])
                    except: pass
                    BATCH_STATUS_MSG.pop(uid, None)
                
                complete_msg = await m.reply_text("Batch processing complete.")
                
                async def auto_delete():
                    await asyncio.sleep(5) 
                    try:
                        await complete_msg.delete()
                    except:
                        pass
                
                asyncio.ensure_future(auto_delete())
                
            else:
                await m.reply_text("Batch list is empty or mode is not ON.")
            return

    if uid in SET_CAPTION_REQUEST:
        SET_CAPTION_REQUEST.discard(uid)
        USER_CAPTIONS[uid] = text
        USER_COUNTERS.pop(uid, None) 
        await m.reply_text("‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶ï‡ßç‡¶Ø‡¶æ‡¶™‡¶∂‡¶® ‡¶∏‡ßá‡¶≠ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§ ‡¶è‡¶ñ‡¶® ‡¶•‡ßá‡¶ï‡ßá ‡¶Ü‡¶™‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡¶æ ‡¶≠‡¶ø‡¶°‡¶ø‡¶ì‡¶§‡ßá ‡¶è‡¶á ‡¶ï‡ßç‡¶Ø‡¶æ‡¶™‡¶∂‡¶® ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶π‡¶¨‡ßá‡•§")
        return

    if m.reply_to_message and m.reply_to_message.id in PENDING_AUDIO_ORDERS:
        prompt_message_id = m.reply_to_message.id
        file_data = PENDING_AUDIO_ORDERS.get(prompt_message_id)
        
        if file_data['uid'] != uid:
             await m.reply_text("‡¶Ü‡¶™‡¶®‡¶ø ‡¶è‡¶á ‡¶´‡¶æ‡¶á‡¶≤‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶¶‡¶ø‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶¨‡ßá‡¶® ‡¶®‡¶æ‡•§")
             return

        tracks = file_data['tracks']
        try:
            new_order_str = [x.strip() for x in text.split(',') if x.strip()]
            num_tracks_in_file = len(tracks)
            
            if not new_order_str:
                 await m.reply_text("‡¶Ü‡¶™‡¶®‡¶æ‡¶ï‡ßá ‡¶Ö‡¶®‡ßç‡¶§‡¶§ ‡¶è‡¶ï‡¶ü‡¶ø ‡¶ü‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶¶‡¶ø‡¶§‡ßá ‡¶π‡¶¨‡ßá‡•§")
                 return

            new_stream_map = []
            valid_user_indices = list(range(1, num_tracks_in_file + 1))
            
            for user_track_num_str in new_order_str:
                user_track_num = int(user_track_num_str) 
                if user_track_num not in valid_user_indices:
                     await m.reply_text(f"‡¶≠‡ßÅ‡¶≤ ‡¶ü‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞: {user_track_num}‡•§ ‡¶ü‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞‡¶ó‡ßÅ‡¶≤‡ßã ‡¶π‡¶§‡ßá ‡¶π‡¶¨‡ßá: {', '.join(map(str, valid_user_indices))}")
                     return
                
                stream_index_to_map = tracks[user_track_num - 1]['stream_index']
                new_stream_map.append(f"0:{stream_index_to_map}") 

            asyncio.create_task(
                handle_audio_remux(
                    c, m, file_data['path'], 
                    file_data['original_name'], 
                    new_stream_map, 
                    messages_to_delete=[prompt_message_id, m.id]
                )
            )

            PENDING_AUDIO_ORDERS.pop(prompt_message_id, None) 
            return

        except ValueError:
            await m.reply_to_message.reply_text("‡¶≠‡ßÅ‡¶≤ ‡¶´‡¶∞‡¶Æ‡ßç‡¶Ø‡¶æ‡¶ü‡•§ ‡¶ï‡¶Æ‡¶æ-‡¶∏‡ßá‡¶™‡¶æ‡¶∞‡ßá‡¶ü‡ßá‡¶° ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶¶‡¶ø‡¶®‡•§ ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£: `1,3`")
            return
        except Exception as e:
            logger.error(f"Audio remux preparation error: {e}")
            await m.reply_to_message.reply_text(f"‡¶Ö‡¶°‡¶ø‡¶ì ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶™‡ßç‡¶∞‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶ï‡¶∞‡¶§‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ: {e}")
            
            try: Path(file_data['path']).unlink(missing_ok=True)
            except Exception: pass
            PENDING_AUDIO_ORDERS.pop(prompt_message_id, None)
            return

    if uid in CREATE_POST_MODE and uid in POST_CREATION_STATE:
        state_data = POST_CREATION_STATE[uid]
        state_data['message_ids'].append(m.id) 
        
        current_state = state_data['state']
        
        if current_state == 'awaiting_name_change':
            if not text:
                prompt_msg = await m.reply_text("‡¶®‡¶æ‡¶Æ ‡¶ñ‡¶æ‡¶≤‡¶ø ‡¶∞‡¶æ‡¶ñ‡¶æ ‡¶Ø‡¶æ‡¶¨‡ßá ‡¶®‡¶æ‡•§ ‡¶∏‡¶†‡¶ø‡¶ï ‡¶®‡¶æ‡¶Æ‡¶ü‡¶ø ‡¶¶‡¶ø‡¶®‡•§")
                state_data['message_ids'].append(prompt_msg.id)
                return
            
            state_data['post_data']['image_name'] = text
            state_data['state'] = 'awaiting_genres_add'
            
            new_caption = generate_post_caption(state_data['post_data'])
            try:
                await c.edit_message_caption(m.chat.id, state_data['post_message_id'], caption=new_caption, parse_mode=ParseMode.MARKDOWN)
            except Exception as e:
                logger.error(f"Edit caption error in name change: {e}")
                await m.reply_text("‡¶ï‡ßç‡¶Ø‡¶æ‡¶™‡¶∂‡¶® ‡¶è‡¶°‡¶ø‡¶ü ‡¶ï‡¶∞‡¶§‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§ ‡¶™‡ßç‡¶∞‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ ‡¶¨‡¶æ‡¶§‡¶ø‡¶≤ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá‡•§ /create_post ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶Æ‡ßã‡¶° ‡¶Ö‡¶´ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§")
                return

            prompt_msg = await m.reply_text(
                f"‚úÖ ‡¶õ‡¶¨‡¶ø‡¶∞ ‡¶®‡¶æ‡¶Æ ‡¶∏‡ßá‡¶ü ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá: `{text}`\n\n**‡¶è‡¶ñ‡¶® Genres ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡ßÅ‡¶®‡•§**\n"
                f"‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£: `Comedy, Romance, Action`"
            )
            state_data['message_ids'].append(prompt_msg.id)
            
        elif current_state == 'awaiting_genres_add':
            state_data['post_data']['genres'] = text 
            state_data['state'] = 'awaiting_season_list'
            
            new_caption = generate_post_caption(state_data['post_data'])
            try:
                await c.edit_message_caption(m.chat.id, state_data['post_message_id'], caption=new_caption, parse_mode=ParseMode.MARKDOWN)
            except Exception as e:
                logger.error(f"Edit caption error in genres add: {e}")
                await m.reply_text("‡¶ï‡ßç‡¶Ø‡¶æ‡¶™‡¶∂‡¶® ‡¶è‡¶°‡¶ø‡¶ü ‡¶ï‡¶∞‡¶§‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§ ‡¶™‡ßç‡¶∞‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ ‡¶¨‡¶æ‡¶§‡¶ø‡¶≤ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá‡•§ /create_post ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶Æ‡ßã‡¶° ‡¶Ö‡¶´ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§")
                return

            prompt_msg = await m.reply_text(
                f"‚úÖ Genres ‡¶∏‡ßá‡¶ü ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá: `{text}`\n\n**‡¶è‡¶ñ‡¶® Season List ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®‡•§**\n"
                f"Change Season List ‡¶è‡¶∞ ‡¶Æ‡¶æ‡¶®‡ßá \"{state_data['post_data']['image_name']}\" Season 01 ‡¶ï‡¶Ø‡¶º‡¶ü‡¶ø add ‡¶ï‡¶∞‡¶¨?\n"
                f"‡¶´‡¶∞‡¶Æ‡ßç‡¶Ø‡¶æ‡¶ü: ‡¶∏‡¶ø‡¶ú‡¶® ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶Ö‡¶•‡¶¨‡¶æ ‡¶∞‡ßá‡¶û‡ßç‡¶ú ‡¶ï‡¶Æ‡¶æ ‡¶¨‡¶æ ‡¶∏‡ßç‡¶™‡ßá‡¶∏-‡¶∏‡ßá‡¶™‡¶æ‡¶∞‡ßá‡¶ü‡ßá‡¶° ‡¶¶‡¶ø‡¶®‡•§\n"
                f"‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£:\n"
                f"‚Ä£ `1` (Season 01)\n"
                f"‚Ä£ `1-2` (Season 01 ‡¶•‡ßá‡¶ï‡ßá Season 02)\n"
                f"‚Ä£ `1-2 4-5` ‡¶¨‡¶æ `1-2, 4-5` (Season 01-02 ‡¶è‡¶¨‡¶Ç 04-05)"
            )
            state_data['message_ids'].append(prompt_msg.id)
            
        elif current_state == 'awaiting_season_list':
            if not text.strip():
                state_data['post_data']['season_list_raw'] = ""
            else:
                state_data['post_data']['season_list_raw'] = text
            
            new_caption = generate_post_caption(state_data['post_data'])
            try:
                await c.edit_message_caption(m.chat.id, state_data['post_message_id'], caption=new_caption, parse_mode=ParseMode.MARKDOWN)
            except Exception as e:
                logger.error(f"Edit caption error in season list: {e}")
                await m.reply_text("‡¶ï‡ßç‡¶Ø‡¶æ‡¶™‡¶∂‡¶® ‡¶è‡¶°‡¶ø‡¶ü ‡¶ï‡¶∞‡¶§‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§ ‡¶™‡ßç‡¶∞‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ ‡¶¨‡¶æ‡¶§‡¶ø‡¶≤ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá‡•§ /create_post ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶Æ‡ßã‡¶° ‡¶Ö‡¶´ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§")
                return

            all_messages = state_data.get('message_ids', [])
            post_id = state_data.get('post_message_id')
            if post_id and post_id in all_messages:
                all_messages.remove(post_id) 
            if all_messages:
                try:
                    await c.delete_messages(m.chat.id, all_messages)
                except Exception as e:
                    logger.warning(f"Error deleting post creation messages: {e}")
            
            image_path = state_data['image_path']
            if image_path and Path(image_path).exists():
                Path(image_path).unlink(missing_ok=True)
            
            CREATE_POST_MODE.discard(uid)
            POST_CREATION_STATE.pop(uid, None)
            
            await m.reply_text("‚úÖ ‡¶™‡ßã‡¶∏‡ßç‡¶ü ‡¶§‡ßà‡¶∞‡¶ø ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶® ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá ‡¶è‡¶¨‡¶Ç ‡¶∏‡¶Æ‡¶∏‡ßç‡¶§ ‡¶Ö‡¶§‡¶ø‡¶∞‡¶ø‡¶ï‡ßç‡¶§ ‡¶¨‡¶æ‡¶∞‡ßç‡¶§‡¶æ ‡¶Æ‡ßÅ‡¶õ‡ßá ‡¶´‡ßá‡¶≤‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§")
            return


    if text.startswith("http://") or text.startswith("https://"):
        asyncio.create_task(handle_url_download_and_upload(c, m, text))
    
@app.on_message(filters.command("upload_url") & filters.private)
async def upload_url_cmd(c, m: Message):
    if not is_admin(m.from_user.id):
        await m.reply_text("‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ö‡¶®‡ßÅ‡¶Æ‡¶§‡¶ø ‡¶®‡ßá‡¶á ‡¶è‡¶á ‡¶ï‡¶Æ‡¶æ‡¶®‡ßç‡¶° ‡¶ö‡¶æ‡¶≤‡¶æ‡¶®‡ßã‡¶∞‡•§")
        return
    if not m.command or len(m.command) < 2:
        await m.reply_text("‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞: /upload_url <url>\n‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£: /upload_url https://example.com/file.mp4")
        return
    url = m.text.split(None, 1)[1].strip()
    asyncio.create_task(handle_url_download_and_upload(c, m, url))

async def handle_url_download_and_upload(c: Client, m: Message, url: str):
    uid = m.from_user.id
    
    try:
        status_msg = await m.reply_text("Searching formats...", reply_markup=progress_keyboard())

        ydl_opts = {'noplaylist': True, 'quiet': True}
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            try:
                info = await asyncio.to_thread(ydl.extract_info, url, download=False)
            except Exception as e:
                if is_drive_url(url):
                     await download_and_process_generic(c, m, url, status_msg)
                     return
                else:
                     await status_msg.edit(f"URL Extract Error: {e}")
                     return

        formats = info.get('formats', [])
        valid_formats = []
        for f in formats:
            if f.get('vcodec') != 'none' or f.get('height'): 
                valid_formats.append(f)
        
        valid_formats.sort(key=lambda x: x.get('height', 0) or 0, reverse=True)
        
        buttons = []
        key_best = f"ytdl_{uid}_best"
        YT_DATA[key_best] = {'url': url, 'format_id': 'bestvideo+bestaudio/best', 'info': info, 'msg_id': status_msg.id}
        buttons.append([InlineKeyboardButton(f"Best Quality", callback_data=key_best)])

        seen_res = set()
        for f in valid_formats:
            h = f.get('height')
            if not h: continue
            res_str = f"{h}p"
            if res_str in seen_res: continue
            seen_res.add(res_str)
            
            ext = f.get('ext', 'mp4')
            key = f"ytdl_{uid}_{f['format_id']}"
            YT_DATA[key] = {'url': url, 'format_id': f['format_id'], 'info': info, 'msg_id': status_msg.id}
            
            btn_text = f"{res_str} | {ext}"
            buttons.append([InlineKeyboardButton(btn_text, callback_data=key)])
        
        key_mp3 = f"ytdl_{uid}_mp3"
        YT_DATA[key_mp3] = {'url': url, 'format_id': 'bestaudio/best', 'info': info, 'msg_id': status_msg.id, 'is_audio': True}
        buttons.append([InlineKeyboardButton("üéµ MP3 (Audio Only)", callback_data=key_mp3)])

        buttons.append([InlineKeyboardButton("Cancel ‚ùå", callback_data="cancel_task")])
        
        await status_msg.edit(
            f"**{info.get('title', 'Video')}**\nSelect Quality:",
            reply_markup=InlineKeyboardMarkup(buttons)
        )
        
    except Exception as e:
        logger.error(f"YTDL Error: {e}")
        try:
            await status_msg.edit(f"Error: {e}")
        except:
             await m.reply_text(f"Error: {e}")

@app.on_callback_query(filters.regex(r"^ytdl_"))
async def ytdl_callback(c: Client, cb: CallbackQuery):
    uid = cb.from_user.id
    key = cb.data
    data = YT_DATA.get(key)
    
    if not data:
        await cb.answer("Data expired.", show_alert=True)
        return
        
    await cb.answer("Download started...")
    
    url = data['url']
    fmt = data['format_id']
    info = data['info']
    msg_id = data['msg_id']
    is_audio = data.get('is_audio', False)
    
    try:
        await c.edit_message_reply_markup(cb.message.chat.id, msg_id, reply_markup=None)
    except: pass
    
    status_msg = await c.get_messages(cb.message.chat.id, msg_id)
    
    cancel_event = asyncio.Event()
    TASKS.setdefault(uid, []).append(cancel_event)
    
    try:
        title = info.get('title', 'video')
        timestamp = int(datetime.now().timestamp())
        
        if is_audio:
            out_tmpl = str(TMP / f"dl_{uid}_{timestamp}.%(ext)s")
            ydl_opts = {
                'format': 'bestaudio/best',
                'outtmpl': out_tmpl,
                'quiet': True,
                'noplaylist': True,
                'postprocessors': [{
                    'key': 'FFmpegExtractAudio',
                    'preferredcodec': 'mp3',
                    'preferredquality': '192',
                }],
            }
        else:
            out_tmpl = str(TMP / f"dl_{uid}_{timestamp}.%(ext)s")
            final_fmt = fmt
            if fmt != 'bestvideo+bestaudio/best':
                final_fmt = f"{fmt}+bestaudio/best"
                
            ydl_opts = {
                'format': final_fmt,
                'outtmpl': out_tmpl,
                'quiet': True,
                'noplaylist': True,
                'merge_output_format': 'mkv' 
            }

        def ytdl_progress_hook(d):
            if cancel_event.is_set():
                raise Exception("Download cancelled by user")

        ydl_opts['progress_hooks'] = [ytdl_progress_hook]
        
        await status_msg.edit(f"Downloading `{title}`...", reply_markup=progress_keyboard())
        
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            await asyncio.to_thread(ydl.download, [url])
            
        expected_prefix = f"dl_{uid}_{timestamp}"
        found_file = None
        for f in TMP.iterdir():
            if f.name.startswith(expected_prefix):
                found_file = f
                break
        
        if not found_file:
            await status_msg.edit(f"Download failed (file not found).")
            return
            
        await status_msg.edit("Download complete. Uploading...", reply_markup=progress_keyboard())
        
        safe_title = re.sub(r"[\\/*?\"<>|:]", "_", title)
        final_filename = f"{safe_title}{found_file.suffix}"
        
        asyncio.create_task(
            sequential_upload_task(uid, c, cb.message, found_file, final_filename, status_msg.id, cancel_event)
        )
        
    except Exception as e:
        if "cancelled" in str(e).lower():
             await status_msg.edit("Download Cancelled.")
        else:
             await status_msg.edit(f"Download Error: {e}")
    finally:
        pass

async def download_and_process_generic(c, m, url, status_msg):
    uid = m.from_user.id
    cancel_event = asyncio.Event()
    TASKS.setdefault(uid, []).append(cancel_event)
    
    try:
        fname = url.split("/")[-1].split("?")[0] or f"download_{int(datetime.now().timestamp())}"
        safe_name = re.sub(r"[\\/*?\"<>|:]", "_", fname)

        video_exts = {".mp4", ".mkv", ".avi", ".mov", ".flv", ".wmv", ".webm"}
        if not any(safe_name.lower().endswith(ext) for ext in video_exts):
            safe_name += ".mp4"

        tmp_in = TMP / f"dl_{uid}_{int(datetime.now().timestamp())}_{safe_name}"
        ok, err = False, None
        
        if is_drive_url(url):
            fid = extract_drive_id(url)
            if not fid:
                await status_msg.edit("Google Drive ID not found.")
                TASKS[uid].remove(cancel_event)
                return
            ok, err = await download_drive_file(fid, tmp_in, status_msg, cancel_event=cancel_event)
        else:
            ok, err = await download_url_generic(url, tmp_in, status_msg, cancel_event=cancel_event)

        if not ok:
            await status_msg.edit(f"Download Failed: {err}")
            if tmp_in.exists(): tmp_in.unlink()
            TASKS[uid].remove(cancel_event)
            return

        await status_msg.edit("Download complete. Uploading...", reply_markup=None)
        renamed_file = generate_new_filename(safe_name)
        
        asyncio.create_task(
            sequential_upload_task(uid, c, m, tmp_in, renamed_file, status_msg.id, cancel_event)
        )
    except Exception as e:
        await status_msg.edit(f"Error: {e}")
    finally:
        pass

async def handle_caption_only_upload(c: Client, m: Message):
    file_info = m.video or m.document
    await handle_caption_only_upload_with_file(c, m, file_info)

async def handle_caption_only_upload_with_file(c: Client, m: Message, file_info):
    uid = m.from_user.id
    caption_to_use = USER_CAPTIONS.get(uid)
    if not caption_to_use:
        await m.reply_text("‡¶ï‡ßç‡¶Ø‡¶æ‡¶™‡¶∂‡¶® ‡¶è‡¶°‡¶ø‡¶ü ‡¶Æ‡ßã‡¶° ‡¶ö‡¶æ‡¶≤‡ßÅ ‡¶Ü‡¶õ‡ßá ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ ‡¶ï‡ßã‡¶®‡ßã ‡¶∏‡ßá‡¶≠ ‡¶ï‡¶∞‡¶æ ‡¶ï‡ßç‡¶Ø‡¶æ‡¶™‡¶∂‡¶® ‡¶®‡ßá‡¶á‡•§ /set_caption ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶ï‡ßç‡¶Ø‡¶æ‡¶™‡¶∂‡¶® ‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶®‡•§")
        return

    cancel_event = asyncio.Event()
    TASKS.setdefault(uid, []).append(cancel_event)
    
    try:
        status_msg = await m.reply_text("‡¶ï‡ßç‡¶Ø‡¶æ‡¶™‡¶∂‡¶® ‡¶è‡¶°‡¶ø‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...", reply_markup=progress_keyboard())
    except Exception:
        status_msg = await m.reply_text("‡¶ï‡ßç‡¶Ø‡¶æ‡¶™‡¶∂‡¶® ‡¶è‡¶°‡¶ø‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...", reply_markup=progress_keyboard())
    
    try:
        source_message = m
        
        if not file_info:
            try:
                await status_msg.edit("‡¶è‡¶ü‡¶ø ‡¶è‡¶ï‡¶ü‡¶ø ‡¶≠‡¶ø‡¶°‡¶ø‡¶ì ‡¶¨‡¶æ ‡¶°‡¶ï‡ßÅ‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶´‡¶æ‡¶á‡¶≤ ‡¶®‡¶Ø‡¶º‡•§")
            except Exception:
                await m.reply_text("‡¶è‡¶ü‡¶ø ‡¶è‡¶ï‡¶ü‡¶ø ‡¶≠‡¶ø‡¶°‡¶ø‡¶ì ‡¶¨‡¶æ ‡¶°‡¶ï‡ßÅ‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶´‡¶æ‡¶á‡¶≤ ‡¶®‡¶Ø‡¶º‡•§")
            return
        
        final_caption = process_dynamic_caption(uid, caption_to_use)
        
        if file_info.file_id:
            try:
                if source_message.video or (file_info and getattr(file_info, 'duration', 0) > 0): # Treat as video
                    await c.send_video(
                        chat_id=m.chat.id,
                        video=file_info.file_id,
                        caption=final_caption,
                        thumb=file_info.thumbs[0].file_id if file_info.thumbs else None,
                        duration=file_info.duration,
                        width=file_info.width,       
                        height=file_info.height,     
                        supports_streaming=True,
                        parse_mode=ParseMode.MARKDOWN
                    )
                else:
                    await c.send_document(
                        chat_id=m.chat.id,
                        document=file_info.file_id,
                        file_name=file_info.file_name,
                        caption=final_caption,
                        thumb=file_info.thumbs[0].file_id if file_info.thumbs else None,
                        parse_mode=ParseMode.MARKDOWN
                    )
                try:
                    await status_msg.delete() 
                except Exception:
                    pass
            except Exception as e:
                try:
                    await status_msg.edit(f"‡¶ï‡ßç‡¶Ø‡¶æ‡¶™‡¶∂‡¶® ‡¶è‡¶°‡¶ø‡¶ü‡ßá ‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø: {e}", reply_markup=None)
                except Exception:
                    await m.reply_text(f"‡¶ï‡ßç‡¶Ø‡¶æ‡¶™‡¶∂‡¶® ‡¶è‡¶°‡¶ø‡¶ü‡ßá ‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø: {e}", reply_markup=None)
                return
        else:
            try:
                await status_msg.edit("‡¶´‡¶æ‡¶á‡¶≤‡ßá‡¶∞ ‡¶´‡¶æ‡¶á‡¶≤ ‡¶Ü‡¶á‡¶°‡¶ø ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø‡•§", reply_markup=None)
            except Exception:
                await m.reply_text("‡¶´‡¶æ‡¶á‡¶≤‡ßá‡¶∞ ‡¶´‡¶æ‡¶á‡¶≤ ‡¶Ü‡¶á‡¶°‡¶ø ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø‡•§", reply_markup=None)
            return

    except Exception as e:
        traceback.print_exc()
        try:
            await status_msg.edit(f"‡¶ï‡ßç‡¶Ø‡¶æ‡¶™‡¶∂‡¶® ‡¶è‡¶°‡¶ø‡¶ü‡ßá ‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø: {e}", reply_markup=None)
        except Exception:
            await m.reply_text(f"‡¶ï‡ßç‡¶Ø‡¶æ‡¶™‡¶∂‡¶® ‡¶è‡¶°‡¶ø‡¶ü‡ßá ‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø: {e}", reply_markup=None)
    finally:
        try:
            TASKS[uid].remove(cancel_event)
        except Exception:
            pass

@app.on_message(filters.private & (filters.video | filters.document))
async def forwarded_file_or_direct_file(c: Client, m: Message):
    uid = m.from_user.id
    if not is_admin(uid):
        return

    if uid in MKV_AUDIO_CHANGE_MODE:
        await handle_audio_change_file(c, m)
        return

    if uid in EDIT_CAPTION_MODE and m.forward_date: 
        
        if uid in BATCH_CAPTION_MODE:
            file_info = m.video or m.document
            if not file_info: 
                return
            
            if uid not in BATCH_DATA: 
                BATCH_DATA[uid] = []
            
            BATCH_DATA[uid].append({
                'message': m,
                'file_info': file_info
            })
            
            count = len(BATCH_DATA[uid])
            status_text = f"{count} ‡¶ü‡¶ø ‡¶≠‡¶ø‡¶°‡¶ø‡¶ì ‡¶è‡¶∞ file id save ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§"
            
            if uid in BATCH_STATUS_MSG:
                try:
                    await c.edit_message_text(m.chat.id, BATCH_STATUS_MSG[uid], status_text)
                except Exception:
                    msg = await m.reply_text(status_text)
                    BATCH_STATUS_MSG[uid] = msg.id
                    
                    await asyncio.sleep(15)
                    try:
                        await msg.delete()
                    except:
                        pass
            else:
                msg = await m.reply_text(status_text)
                BATCH_STATUS_MSG[uid] = msg.id
                
                await asyncio.sleep(15)
                try:
                    await msg.delete()
                    if uid in BATCH_STATUS_MSG:
                        del BATCH_STATUS_MSG[uid]
                except:
                    pass
            return

        await handle_caption_only_upload(c, m)
        return

    if m.forward_date:
        
        file_info = m.video or m.document
        
        if file_info and file_info.file_name:
            original_name = file_info.file_name
        elif m.video:
            original_name = f"video_{file_info.file_unique_id}.mp4"
        else:
            original_name = f"file_{file_info.file_unique_id}"

        if uid not in USER_QUEUES:
            USER_QUEUES[uid] = asyncio.Queue()
        
        try:
            status_msg = await m.reply_text(f"Queue: Processing started for `{original_name}`...", reply_markup=progress_keyboard())
        except:
            status_msg = None

        await USER_QUEUES[uid].put({
            'message': m,
            'original_name': original_name,
            'status_msg': status_msg 
        })
        
        if uid not in USER_WORKERS or USER_WORKERS[uid].done():
             USER_WORKERS[uid] = asyncio.create_task(process_queue_handler(uid, c))
        else:
             pass
        
    else:
        pass

async def handle_audio_change_file(c: Client, m: Message):
    uid = m.from_user.id
    file_info = m.video or m.document
    
    if not file_info:
        await m.reply_text("‡¶è‡¶ü‡¶ø ‡¶è‡¶ï‡¶ü‡¶ø ‡¶≠‡¶ø‡¶°‡¶ø‡¶ì ‡¶´‡¶æ‡¶á‡¶≤ ‡¶®‡¶Ø‡¶º‡•§")
        return
    
    cancel_event = asyncio.Event()
    TASKS.setdefault(uid, []).append(cancel_event)
    
    tmp_path = None
    status_msg = None
    try:
        original_name = file_info.file_name or f"video_{file_info.file_unique_id}.mkv"
        if not '.' in original_name:
            original_name += '.mkv'
            
        tmp_path = TMP / f"audio_change_{uid}_{int(datetime.now().timestamp())}_{original_name}"
        
        status_msg = await m.reply_text("‡¶Ö‡¶°‡¶ø‡¶ì ‡¶ü‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï ‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶£‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶´‡¶æ‡¶á‡¶≤ ‡¶°‡¶æ‡¶â‡¶®‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...", reply_markup=progress_keyboard())
        await m.download(file_name=str(tmp_path))
        
        audio_tracks = await asyncio.to_thread(get_audio_tracks_ffprobe, tmp_path)
        
        if not audio_tracks:
            await status_msg.edit("‡¶è‡¶á ‡¶≠‡¶ø‡¶°‡¶ø‡¶ì‡¶§‡ßá ‡¶ï‡ßã‡¶®‡ßã ‡¶Ö‡¶°‡¶ø‡¶ì ‡¶ü‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø ‡¶¨‡¶æ FFprobe ‡¶ö‡¶≤‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡¶®‡¶ø‡•§")
            tmp_path.unlink(missing_ok=True)
            return

        if len(audio_tracks) == 1:
            await status_msg.edit("‡¶´‡¶æ‡¶á‡¶≤‡¶ü‡¶ø‡¶§‡ßá ‡ßß‡¶ü‡¶ø ‡¶Ö‡¶°‡¶ø‡¶ì ‡¶ü‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï ‡¶∞‡ßü‡ßá‡¶õ‡ßá‡•§ ‡¶∏‡ßç‡¶¨‡¶Ø‡¶º‡¶Ç‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶≠‡¶æ‡¶¨‡ßá ‡¶∞‡¶ø‡¶Æ‡¶æ‡¶ï‡ßç‡¶∏ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...", reply_markup=progress_keyboard())
            
            stream_index = audio_tracks[0]['stream_index']
            new_stream_map = [f"0:{stream_index}"]
            
            asyncio.create_task(
                handle_audio_remux(
                    c, m, tmp_path, 
                    original_name, 
                    new_stream_map, 
                    messages_to_delete=[status_msg.id]
                )
            )
            
            return 

        track_list_text = "‡¶´‡¶æ‡¶á‡¶≤‡ßá‡¶∞ ‡¶Ö‡¶°‡¶ø‡¶ì ‡¶ü‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï‡¶∏‡¶Æ‡ßÇ‡¶π:\n\n"
        for i, track in enumerate(audio_tracks, 1):
            track_list_text += f"{i}. **Stream Index:** {track['stream_index']}, **Language:** {track['language']}, **Title:** {track['title']}\n"
            
        track_list_text += (
            "\n**‡¶Ö‡¶°‡¶ø‡¶ì ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶¶‡¶ø‡¶§‡ßá ‡¶è‡¶á ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú‡¶ü‡¶ø‡¶§‡ßá ‡¶∞‡¶ø‡¶™‡ßç‡¶≤‡¶æ‡¶á ‡¶ï‡¶∞‡ßá** ‡¶ï‡¶Æ‡¶æ-‡¶∏‡ßá‡¶™‡¶æ‡¶∞‡ßá‡¶ü‡ßá‡¶° ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ‡¶Ø‡¶º ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶ü‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞‡¶ó‡ßÅ‡¶≤‡ßã ‡¶¶‡¶ø‡¶®‡•§\n"
            "‡¶Ø‡ßá‡¶Æ‡¶®: `1,3` ‡¶¶‡¶ø‡¶≤‡ßá ‡ßß ‡¶è‡¶¨‡¶Ç ‡ß© ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶ü‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï ‡¶•‡¶æ‡¶ï‡¶¨‡ßá‡•§ `2` ‡¶¶‡¶ø‡¶≤‡ßá ‡¶∂‡ßÅ‡¶ß‡ßÅ ‡ß® ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶ü‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï ‡¶•‡¶æ‡¶ï‡¶¨‡ßá‡•§ ‡¶¨‡¶æ‡¶ï‡¶ø‡¶ó‡ßÅ‡¶≤‡ßã ‡¶Æ‡ßÅ‡¶õ‡ßá ‡¶Ø‡¶æ‡¶¨‡ßá‡•§\n"
        )
            
        track_list_text += (
            "\n‡¶Ö‡¶°‡¶ø‡¶ì ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶®‡¶æ ‡¶ï‡¶∞‡¶§‡ßá ‡¶ö‡¶æ‡¶á‡¶≤‡ßá, ‡¶è‡¶á ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú‡ßá‡¶∞ `Cancel` ‡¶¨‡¶æ‡¶ü‡¶®‡¶ü‡¶ø ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶® ‡¶Ö‡¶•‡¶¨‡¶æ `/mkv_video_audio_change` ‡¶≤‡¶ø‡¶ñ‡ßá ‡¶Æ‡ßã‡¶° ‡¶Ö‡¶´ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§"
        )
        
        await status_msg.edit(track_list_text, reply_markup=progress_keyboard()) 
        
        PENDING_AUDIO_ORDERS[status_msg.id] = {
            'uid': uid,
            'path': tmp_path, 
            'original_name': original_name,
            'tracks': audio_tracks
        }
        
    except Exception as e:
        logger.error(f"Audio track analysis error: {e}")
        if status_msg:
            await status_msg.edit(f"‡¶Ö‡¶°‡¶ø‡¶ì ‡¶ü‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï ‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶£‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ: {e}")
        else:
            await m.reply_text(f"‡¶Ö‡¶°‡¶ø‡¶ì ‡¶ü‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï ‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶£‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ: {e}")
        if tmp_path and tmp_path.exists():
            tmp_path.unlink(missing_ok=True)
    finally:
        try:
            TASKS[uid].remove(cancel_event)
        except Exception:
            pass

async def handle_audio_remux(c: Client, m: Message, in_path: Path, original_name: str, new_stream_map: list, messages_to_delete: list = None):
    uid = m.from_user.id
    cancel_event = asyncio.Event()
    TASKS.setdefault(uid, []).append(cancel_event)
    
    out_name = generate_new_filename(original_name)
    if not out_name.lower().endswith(".mkv"):
        out_name = Path(out_name).stem + ".mkv"
    
    asyncio.create_task(
        sequential_remux_upload_task(uid, c, m, in_path, out_name, new_stream_map, messages_to_delete, cancel_event)
    )

async def sequential_remux_upload_task(uid, c, m, in_path, out_name, new_stream_map, messages_to_delete, cancel_event):
    if uid not in USER_UPLOAD_LOCKS:
        USER_UPLOAD_LOCKS[uid] = asyncio.Lock()
    
    async with USER_UPLOAD_LOCKS[uid]:
        if cancel_event.is_set():
             if in_path.exists(): in_path.unlink()
             return

        out_path = TMP / f"remux_{uid}_{int(datetime.now().timestamp())}_{out_name}"
        
        map_args = ["-map", "0:v", "-map", "0:s?", "-map", "0:d?"] 
        for stream_index in new_stream_map:
            map_args.extend(["-map", stream_index])
            
        cmd = [
            "ffmpeg",
            "-i", str(in_path),
            "-disposition:a", "0",            
            *map_args,
            "-disposition:a:0", "default",
            "-metadata:s:a", "title=[@TA_HD_Anime] Telegram Channel", 
            "-c", "copy",
            "-metadata", "handler_name=", 
            str(out_path)
        ]

        status_msg = None
        if messages_to_delete:
             pass

        try:
            status_msg = await m.reply_text("‡¶Ö‡¶°‡¶ø‡¶ì ‡¶ü‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá (Remuxing)...", reply_markup=progress_keyboard())
            
            result = await asyncio.to_thread(
                subprocess.run,
                cmd,
                capture_output=True,
                text=True,
                check=False,
                timeout=3600
            )
            
            if result.returncode != 0:
                logger.error(f"FFmpeg Remux failed: {result.stderr}")
                out_path.unlink(missing_ok=True)
                raise Exception(f"FFmpeg Remux ‡¶¨‡ßç‡¶Ø‡¶∞‡ßç‡¶• ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§ ‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø: {result.stderr[:500]}...")

            if not out_path.exists() or out_path.stat().st_size == 0:
                raise Exception("‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶ø‡¶§ ‡¶´‡¶æ‡¶á‡¶≤‡¶ü‡¶ø ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø ‡¶¨‡¶æ ‡¶∂‡ßÇ‡¶®‡ßç‡¶Ø ‡¶Ü‡¶ï‡¶æ‡¶∞‡ßá‡¶∞‡•§")

            await status_msg.edit("‡¶Ö‡¶°‡¶ø‡¶ì ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶®, ‡¶´‡¶æ‡¶á‡¶≤ ‡¶Ü‡¶™‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...", reply_markup=progress_keyboard())
            
            all_messages_to_delete = messages_to_delete if messages_to_delete else []
            all_messages_to_delete.append(status_msg.id)

            await process_file_and_upload(c, m, out_path, original_name=out_name, messages_to_delete=all_messages_to_delete, cancel_event_passed=cancel_event) 

        except Exception as e:
            logger.error(f"Audio remux process error: {e}")
            try:
                if status_msg:
                    await status_msg.edit(f"‡¶Ö‡¶°‡¶ø‡¶ì ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶™‡ßç‡¶∞‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ ‡¶¨‡ßç‡¶Ø‡¶∞‡ßç‡¶•: {e}")
                else:
                    await m.reply_text(f"‡¶Ö‡¶°‡¶ø‡¶ì ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶™‡ßç‡¶∞‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ ‡¶¨‡ßç‡¶Ø‡¶∞‡ßç‡¶•: {e}")
            except Exception:
                pass
        finally:
            try:
                in_path.unlink(missing_ok=True)
                if out_path.exists(): out_path.unlink(missing_ok=True)
                TASKS[uid].remove(cancel_event)
            except Exception:
                pass


@app.on_message(filters.command("rename") & filters.private)
async def rename_cmd(c, m: Message):
    uid = m.from_user.id
    if not is_admin(uid):
        await m.reply_text("‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ö‡¶®‡ßÅ‡¶Æ‡¶§‡¶ø ‡¶®‡ßá‡¶á‡•§")
        return
    if not m.reply_to_message or not (m.reply_to_message.video or m.reply_to_message.document):
        await m.reply_text("‡¶≠‡¶ø‡¶°‡¶ø‡¶ì/‡¶°‡¶ï‡ßÅ‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶´‡¶æ‡¶á‡¶≤‡ßá‡¶∞ reply ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶è‡¶á ‡¶ï‡¶Æ‡¶æ‡¶®‡ßç‡¶° ‡¶¶‡¶ø‡¶®‡•§\nUsage: /rename new_name.mp4")
        return
    if len(m.command) < 2:
        await m.reply_text("‡¶®‡¶§‡ßÅ‡¶® ‡¶´‡¶æ‡¶á‡¶≤ ‡¶®‡¶æ‡¶Æ ‡¶¶‡¶ø‡¶®‡•§ ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£: /rename new_video.mp4")
        return
    new_name = m.text.split(None, 1)[1].strip()
    new_name = re.sub(r"[\\/*?\"<>|:]", "_", new_name)
    
    await m.reply_text(f"‡¶≠‡¶ø‡¶°‡¶ø‡¶ì ‡¶∞‡¶ø‡¶®‡ßá‡¶Æ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶¨‡ßá: {new_name}\n(‡¶∞‡¶ø‡¶®‡ßá‡¶Æ ‡¶ï‡¶∞‡¶§‡ßá reply ‡¶ï‡¶∞‡¶æ ‡¶´‡¶æ‡¶á‡¶≤‡¶ü‡¶ø ‡¶™‡ßÅ‡¶®‡¶∞‡¶æ‡¶Ø‡¶º ‡¶°‡¶æ‡¶â‡¶®‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡ßá ‡¶Ü‡¶™‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡¶æ ‡¶π‡¶¨‡ßá)")

    cancel_event = asyncio.Event()
    TASKS.setdefault(uid, []).append(cancel_event)
    try:
        status_msg = await m.reply_text("‡¶∞‡¶ø‡¶®‡ßá‡¶Æ‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶´‡¶æ‡¶á‡¶≤ ‡¶°‡¶æ‡¶â‡¶®‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...", reply_markup=progress_keyboard())
    except Exception:
        status_msg = await m.reply_text("‡¶∞‡¶ø‡¶®‡ßá‡¶Æ‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶´‡¶æ‡¶á‡¶≤ ‡¶°‡¶æ‡¶â‡¶®‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...", reply_markup=progress_keyboard())
    tmp_out = TMP / f"rename_{uid}_{int(datetime.now().timestamp())}_{new_name}"
    try:
        await m.reply_to_message.download(file_name=str(tmp_out))
        try:
            await status_msg.edit("‡¶°‡¶æ‡¶â‡¶®‡¶≤‡ßã‡¶° ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶®, ‡¶è‡¶ñ‡¶® ‡¶®‡¶§‡ßÅ‡¶® ‡¶®‡¶æ‡¶Æ ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶Ü‡¶™‡¶≤‡ßã‡¶° ‡¶π‡¶ö‡ßç‡¶õ‡ßá...", reply_markup=None)
        except Exception:
            await m.reply_text("‡¶°‡¶æ‡¶â‡¶®‡¶≤‡ßã‡¶° ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶®, ‡¶è‡¶ñ‡¶® ‡¶®‡¶§‡ßÅ‡¶® ‡¶®‡¶æ‡¶Æ ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶Ü‡¶™‡¶≤‡ßã‡¶° ‡¶π‡¶ö‡ßç‡¶õ‡ßá...", reply_markup=None)
        
        asyncio.create_task(
            sequential_upload_task(uid, c, m, tmp_out, new_name, status_msg.id, cancel_event)
        )
    except Exception as e:
        await m.reply_text(f"‡¶∞‡¶ø‡¶®‡ßá‡¶Æ ‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø: {e}")
    finally:
        pass

@app.on_callback_query(filters.regex("cancel_task"))
async def cancel_task_cb(c, cb):
    uid = cb.from_user.id
    prompt_message_id = cb.message.id

    if prompt_message_id in PENDING_AUDIO_ORDERS:
        file_data = PENDING_AUDIO_ORDERS.pop(prompt_message_id)
        if file_data['uid'] == uid:
            try:
                Path(file_data['path']).unlink(missing_ok=True)
            except Exception:
                pass
            
            for ev in list(TASKS.get(uid, [])):
                try: ev.set()
                except: pass

            await cb.answer("‡¶Ö‡¶°‡¶ø‡¶ì ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶™‡ßç‡¶∞‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ ‡¶¨‡¶æ‡¶§‡¶ø‡¶≤ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§", show_alert=True)
            try:
                await cb.message.delete()
            except Exception:
                pass
            return
    
    if uid in TASKS and TASKS[uid]:
        count = 0
        for ev in list(TASKS[uid]):
            try:
                ev.set()
                count += 1
            except:
                pass
        
        await cb.answer(f"{count}‡¶ü‡¶ø ‡¶Ö‡¶™‡¶æ‡¶∞‡ßá‡¶∂‡¶® ‡¶¨‡¶æ‡¶§‡¶ø‡¶≤ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§", show_alert=True)
        try:
            await cb.message.delete()
        except Exception:
            pass
    else:
        await cb.answer("‡¶ï‡ßã‡¶®‡ßã ‡¶Ö‡¶™‡¶æ‡¶∞‡ßá‡¶∂‡¶® ‡¶ö‡¶≤‡¶õ‡ßá ‡¶®‡¶æ‡•§", show_alert=True)

async def generate_video_thumbnail(video_path: Path, thumb_path: Path, timestamp_sec: int = 1):
    try:
        cmd = [
            "ffmpeg",
            "-y",
            "-i", str(video_path),
            "-ss", str(timestamp_sec),
            "-vframes", "1",
            "-vf", "scale=320:-1",
            str(thumb_path)
        ]
        subprocess.run(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=False)
        return thumb_path.exists() and thumb_path.stat().st_size > 0
    except Exception as e:
        logger.warning("Thumbnail generate error: %s", e)
        return False


def process_dynamic_caption(uid, caption_template):
    if uid not in USER_COUNTERS:
        USER_COUNTERS[uid] = {'uploads': 0, 'episode_numbers': {}, 'dynamic_counters': {}, 're_options_count': 0}

    USER_COUNTERS[uid]['uploads'] += 1

    quality_match = re.search(r"\[re\s*\((.*?)\)\]", caption_template)
    if quality_match:
        options_str = quality_match.group(1)
        options = [opt.strip() for opt in options_str.split(',')]
        
        if not USER_COUNTERS[uid]['re_options_count']:
            USER_COUNTERS[uid]['re_options_count'] = len(options)
        
        current_index = (USER_COUNTERS[uid]['uploads'] - 1) % len(options)
        current_quality = options[current_index]
        
        caption_template = caption_template.replace(quality_match.group(0), current_quality)

        if (USER_COUNTERS[uid]['uploads'] - 1) % USER_COUNTERS[uid]['re_options_count'] == 0 and USER_COUNTERS[uid]['uploads'] > 1:
            for key in USER_COUNTERS[uid]['dynamic_counters']:
                USER_COUNTERS[uid]['dynamic_counters'][key]['value'] += 1
    elif USER_COUNTERS[uid]['uploads'] > 1: 
        for key in USER_COUNTERS[uid].get('dynamic_counters', {}):
             USER_COUNTERS[uid]['dynamic_counters'][key]['value'] += 1


    counter_matches = re.findall(r"\[\s*(\(?\d+\)?)\s*\]", caption_template)
    
    if USER_COUNTERS[uid]['uploads'] == 1:
        for match in counter_matches:
            has_paren = match.startswith('(') and match.endswith(')')
            clean_match = re.sub(r'[()]', '', match)
            USER_COUNTERS[uid]['dynamic_counters'][match] = {'value': int(clean_match), 'has_paren': has_paren}
    
    for match, data in USER_COUNTERS[uid]['dynamic_counters'].items():
        value = data['value']
        has_paren = data['has_paren']
        
        original_num_len = len(re.sub(r'[()]', '', match))
        formatted_value = f"{value:0{original_num_len}d}"

        final_value = f"({formatted_value})" if has_paren else formatted_value
        
        caption_template = re.sub(re.escape(f"[{match}]"), final_value, caption_template)


    current_episode_num = 0
    if USER_COUNTERS[uid].get('dynamic_counters'):
        current_episode_num = min(data['value'] for data in USER_COUNTERS[uid]['dynamic_counters'].values())

    conditional_matches = re.findall(r"\[([a-zA-Z0-9\s]+)\s*\((.*?)\)\]", caption_template)

    for match in conditional_matches:
        text_to_add = match[0].strip() 
        target_num_str = re.sub(r'[^0-9]', '', match[1]).strip() 

        placeholder = re.escape(f"[{match[0].strip()} ({match[1].strip()})]")
        
        try:
            target_num = int(target_num_str)
        except ValueError:
            caption_template = re.sub(placeholder, "", caption_template)
            continue
        
        if current_episode_num == target_num:
            caption_template = re.sub(placeholder, text_to_add, caption_template)
        else:
            caption_template = re.sub(placeholder, "", caption_template)

    return "**" + "\n".join(caption_template.splitlines()) + "**"


async def process_file_and_upload(c: Client, m: Message, in_path: Path, original_name: str = None, messages_to_delete: list = None, cancel_event_passed: asyncio.Event = None):
    uid = m.from_user.id
    cancel_event = cancel_event_passed
    if not cancel_event:
        cancel_event = asyncio.Event()
        TASKS.setdefault(uid, []).append(cancel_event)
    
    upload_path = in_path
    temp_thumb_path = None
    final_caption_template = USER_CAPTIONS.get(uid)
    status_msg = None 

    try:
        if cancel_event.is_set():
             raise Exception("Cancelled")

        input_name = in_path.name
        target_name = original_name or input_name
        
        video_exts = {".mp4", ".mkv", ".avi", ".mov", ".flv", ".wmv", ".webm"}
        audio_exts = {".mp3", ".m4a", ".flac", ".wav", ".aac"}
        
        is_video_file = bool(m.video) or any(input_name.lower().endswith(ext) for ext in video_exts)
        is_audio_file = any(input_name.lower().endswith(ext) for ext in audio_exts)
        
        if is_video_file:
            is_mp4_container = input_name.lower().endswith(".mp4")
            is_mkv_container = input_name.lower().endswith(".mkv")
            has_opus = has_opus_audio(in_path)
            
            if is_mp4_container:
                if has_opus:
                    final_ext = ".mkv" 
                else:
                    final_ext = ".mp4" 
            elif is_mkv_container:
                final_ext = ".mkv" 
            else:
                final_ext = ".mkv" 
            
            target_stem = Path(target_name).stem
            target_name = target_stem + final_ext
            
            processed_path = TMP / f"proc_{uid}_{int(datetime.now().timestamp())}_{target_name}"
            
            try:
                status_text = "‡¶≠‡¶ø‡¶°‡¶ø‡¶ì ‡¶™‡ßç‡¶∞‡¶∏‡ßá‡¶∏ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá (Metadata & Format Check)..."
                status_msg = await m.reply_text(status_text, reply_markup=progress_keyboard())
            except Exception:
                status_msg = await m.reply_text(status_text, reply_markup=progress_keyboard())
            
            if messages_to_delete:
                messages_to_delete.append(status_msg.id)
            else:
                messages_to_delete = [status_msg.id]

            cmd = [
                "ffmpeg",
                "-i", str(in_path),
                "-map", "0", 
                "-c", "copy", 
                "-metadata:s:a", "title=[@TA_HD_Anime] Telegram Channel", 
                "-metadata", "handler_name=",
                str(processed_path)
            ]
            
            if cancel_event.is_set(): raise Exception("Cancelled")
            
            result = await asyncio.to_thread(subprocess.run, cmd, capture_output=True, text=True, check=False, timeout=3600)
            
            if result.returncode == 0 and processed_path.exists() and processed_path.stat().st_size > 0:
                upload_path = processed_path
            else:
                logger.warning(f"Processing failed: {result.stderr}. Uploading original.")
                pass

        if is_video_file:
            thumb_path = USER_THUMBS.get(uid)
            if not thumb_path:
                temp_thumb_path = TMP / f"thumb_{uid}_{int(datetime.now().timestamp())}.jpg"
                thumb_time_sec = USER_THUMB_TIME.get(uid, 1) 
                ok = await generate_video_thumbnail(upload_path, temp_thumb_path, timestamp_sec=thumb_time_sec)
                if ok:
                    thumb_path = str(temp_thumb_path)

        try:
            if status_msg:
                await status_msg.edit("‡¶Ü‡¶™‡¶≤‡ßã‡¶° ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...", reply_markup=progress_keyboard())
            else:
                status_msg = await m.reply_text("‡¶Ü‡¶™‡¶≤‡ßã‡¶° ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...", reply_markup=progress_keyboard())
        except Exception:
             status_msg = await m.reply_text("‡¶Ü‡¶™‡¶≤‡ßã‡¶° ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...", reply_markup=progress_keyboard())
             
        if messages_to_delete:
            if status_msg.id not in messages_to_delete:
                messages_to_delete.append(status_msg.id)
        else:
            messages_to_delete = [status_msg.id]


        if cancel_event.is_set():
            raise Exception("Cancelled")
        
        video_metadata = get_video_metadata(upload_path) if (is_video_file and upload_path.exists()) else {'duration': 0, 'width': 0, 'height': 0}
        duration_sec = video_metadata.get('duration', 0)
        width_px = video_metadata.get('width', 0)
        height_px = video_metadata.get('height', 0)
        
        caption_to_use = f"**{target_name}**" 
        if final_caption_template:
            caption_to_use = process_dynamic_caption(uid, final_caption_template)

        upload_attempts = 3
        last_exc = None
        for attempt in range(1, upload_attempts + 1):
            try:
                if cancel_event.is_set(): raise Exception("Cancelled")

                async def progress(current, total):
                    if cancel_event.is_set():
                        c.stop_transmission()

                if is_video_file:
                    await c.send_video(
                        chat_id=m.chat.id,
                        video=str(upload_path),
                        caption=caption_to_use,
                        thumb=thumb_path,
                        duration=duration_sec,
                        width=width_px,
                        height=height_px,
                        supports_streaming=True,
                        file_name=target_name, 
                        parse_mode=ParseMode.MARKDOWN,
                        progress=progress
                    )
                elif is_audio_file:
                     await c.send_audio(
                        chat_id=m.chat.id,
                        audio=str(upload_path),
                        file_name=target_name,
                        caption=caption_to_use,
                        parse_mode=ParseMode.MARKDOWN,
                        progress=progress
                    )
                else:
                    await c.send_document(
                        chat_id=m.chat.id,
                        document=str(upload_path),
                        file_name=target_name,
                        caption=caption_to_use,
                        parse_mode=ParseMode.MARKDOWN,
                        progress=progress
                    )
                
                if messages_to_delete:
                    try:
                        await c.delete_messages(chat_id=m.chat.id, message_ids=messages_to_delete)
                    except Exception:
                        pass
                
                last_exc = None
                break
            except Exception as e:
                last_exc = e
                if "Cancelled" in str(e):
                    break
                logger.warning("Upload attempt %s failed: %s", attempt, e)
                await asyncio.sleep(2 * attempt)
        
        if last_exc:
            msg_text = "‡¶Ö‡¶™‡¶æ‡¶∞‡ßá‡¶∂‡¶® ‡¶¨‡¶æ‡¶§‡¶ø‡¶≤ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§" if "Cancelled" in str(last_exc) else f"‡¶Ü‡¶™‡¶≤‡ßã‡¶° ‡¶¨‡ßç‡¶Ø‡¶∞‡ßç‡¶•: {last_exc}"
            if status_msg:
                await status_msg.edit(msg_text, reply_markup=None)
            else:
                await m.reply_text(msg_text, reply_markup=None)

    except Exception as e:
        msg_text = "‡¶Ö‡¶™‡¶æ‡¶∞‡ßá‡¶∂‡¶® ‡¶¨‡¶æ‡¶§‡¶ø‡¶≤ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§" if "Cancelled" in str(e) else f"‡¶Ü‡¶™‡¶≤‡ßã‡¶°‡ßá ‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø: {e}"
        if status_msg:
            await status_msg.edit(msg_text)
        else:
            await m.reply_text(msg_text)
    finally:
        try:
            if upload_path != in_path and upload_path.exists():
                upload_path.unlink()
            if in_path.exists():
                in_path.unlink()
            if temp_thumb_path and Path(temp_thumb_path).exists():
                Path(temp_thumb_path).unlink()
            TASKS[uid].remove(cancel_event)
        except Exception:
            pass

@app.on_message(filters.command("broadcast") & filters.private)
async def broadcast_cmd_no_reply(c, m: Message):
    uid = m.from_user.id
    if not is_admin(uid):
        await m.reply_text("‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ö‡¶®‡ßÅ‡¶Æ‡¶§‡¶ø ‡¶®‡ßá‡¶á‡•§")
        return
    if not m.reply_to_message:
        await m.reply_text("‡¶¨‡ßç‡¶∞‡¶°‡¶ï‡¶æ‡¶∏‡ßç‡¶ü ‡¶ï‡¶∞‡¶§‡ßá ‡¶Ø‡ßá‡¶ï‡ßã‡¶®‡ßã ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú‡ßá (‡¶õ‡¶¨‡¶ø, ‡¶≠‡¶ø‡¶°‡¶ø‡¶ì ‡¶¨‡¶æ ‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü) **‡¶∞‡¶ø‡¶™‡ßç‡¶≤‡¶æ‡¶á ‡¶ï‡¶∞‡ßá** ‡¶è‡¶á ‡¶ï‡¶Æ‡¶æ‡¶®‡ßç‡¶° ‡¶¶‡¶ø‡¶®‡•§")
        return

@app.on_message(filters.command("broadcast") & filters.private & filters.reply)
async def broadcast_cmd_reply(c, m: Message):
    uid = m.from_user.id
    if not is_admin(uid):
        await m.reply_text("‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ö‡¶®‡ßÅ‡¶Æ‡¶§‡¶ø ‡¶®‡ßá‡¶á‡•§")
        return
    
    source_message = m.reply_to_message
    if not source_message:
        await m.reply_text("‡¶¨‡ßç‡¶∞‡¶°‡¶ï‡¶æ‡¶∏‡ßç‡¶ü ‡¶ï‡¶∞‡¶§‡ßá ‡¶Ø‡ßá‡¶ï‡ßã‡¶®‡ßã ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú‡ßá ‡¶∞‡¶ø‡¶™‡ßç‡¶≤‡¶æ‡¶á ‡¶ï‡¶∞‡ßá ‡¶è‡¶á ‡¶ï‡¶Æ‡¶æ‡¶®‡ßç‡¶° ‡¶¶‡¶ø‡¶®‡•§")
        return

    await m.reply_text(f"‡¶¨‡ßç‡¶∞‡¶°‡¶ï‡¶æ‡¶∏‡ßç‡¶ü ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶π‡¶ö‡ßç‡¶õ‡ßá {len(SUBSCRIBERS)} ‡¶∏‡¶æ‡¶¨‡¶∏‡ßç‡¶ï‡ßç‡¶∞‡¶æ‡¶á‡¶¨‡¶æ‡¶∞‡ßá...", quote=True)
    failed = 0
    sent = 0
    for chat_id in list(SUBSCRIBERS):
        if chat_id == m.chat.id:
            continue
        try:
            await c.forward_messages(chat_id=chat_id, from_chat_id=source_message.chat.id, message_ids=source_message.id)
            sent += 1
            await asyncio.sleep(0.08)
        except Exception as e:
            failed += 1
            logger.warning("Broadcast to %s failed: %s", chat_id, e)

    await m.reply_text(f"‡¶¨‡ßç‡¶∞‡¶°‡¶ï‡¶æ‡¶∏‡ßç‡¶ü ‡¶∂‡ßá‡¶∑‡•§ ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡ßã: {sent}, ‡¶¨‡ßç‡¶Ø‡¶∞‡ßç‡¶•: {failed}")

@flask_app.route('/')
def home():
    html_content = """
    <!DOCTYPE-html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Bot Status</title>
        <style>
            body {
                font-family: Arial, sans-serif;
                background-color: #f0f2f5;
                color: #333;
                text-align: center;
                padding-top: 50px;
            }
            .container {
                background-color: #fff;
                padding: 30px;
                border-radius: 10px;
                box-shadow: 0 4px 8px rgba(0,0,0,0.1);
                display: inline-block;
            }
            h1 {
                color: #28a745;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>TA File Share Bot is running! ‚úÖ</h1>
            <p>This page confirms that the bot's web server is active.</p>
        </div>
    </body>
    </html>
    """
    return render_template_string(html_content)

def ping_service():
    if not RENDER_EXTERNAL_HOSTNAME:
        print("Render URL is not set. Ping service is disabled.")
        return

    url = f"http://{RENDER_EXTERNAL_HOSTNAME}"
    while True:
        try:
            response = requests.get(url, timeout=10)
            print(f"Pinged {url} | Status Code: {response.status_code}")
        except requests.exceptions.RequestException as e:
            print(f"Error pinging {url}: {e}")
        time.sleep(600)

def run_flask_and_ping():
    flask_thread = threading.Thread(target=lambda: flask_app.run(host="0.0.0.0", port=PORT, use_reloader=False))
    flask_thread.start()
    ping_thread = threading.Thread(target=ping_service)
    ping_thread.start()
    print("Flask and Ping services started.")

async def periodic_cleanup():
    while True:
        try:
            now = datetime.now()
            for p in TMP.iterdir():
                try:
                    if p.is_file():
                        if now - datetime.fromtimestamp(p.stat().st_mtime) > timedelta(days=3):
                            p.unlink()
                except Exception:
                    pass
        except Exception:
            pass
        await asyncio.sleep(3600)

if __name__ == "__main__":
    print("Bot ‡¶ö‡¶æ‡¶≤‡ßÅ ‡¶π‡¶ö‡ßç‡¶õ‡ßá... Flask and Ping threads start ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá, ‡¶§‡¶æ‡¶∞‡¶™‡¶∞ Pyrogram ‡¶ö‡¶æ‡¶≤‡ßÅ ‡¶π‡¶¨‡ßá‡•§")
    t = threading.Thread(target=run_flask_and_ping, daemon=True)
    t.start()
    try:
        loop = asyncio.get_event_loop()
        loop.create_task(periodic_cleanup())
    except RuntimeError:
        pass
    app.run()
